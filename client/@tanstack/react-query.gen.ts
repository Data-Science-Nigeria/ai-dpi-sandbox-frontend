// This file is auto-generated by @hey-api/openapi-ts

import {
  type Options,
  defaultHealthCheck,
  defaultRoot,
  defaultGatewayHealth,
  defaultTestMetrics,
  defaultMetricsEndpoint,
  apiGetRootRoot,
  authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration,
  authenticationGetApiV1AuthWellKnownJwksJsonJwks,
  authenticationPostApiV1AuthLoginLoginUser,
  authenticationPostApiV1AuthLoginJsonLoginUserJson,
  authenticationGetApiV1AuthMeReadUserMe,
  authenticationPostApiV1AuthLogoutLogoutUser,
  oauth2PostApiV1Oauth2ClientsCreateOauthClient,
  oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient,
  oauth2GetApiV1Oauth2AuthorizeAuthorize,
  oauth2PostApiV1Oauth2TokenGetToken,
  adminGetApiV1AdminUsersListUsers,
  adminPostApiV1AdminUsersCreateUser,
  adminDeleteApiV1AdminUsersUserIdDeleteUser,
  adminGetApiV1AdminUsersUserIdGetUser,
  adminPutApiV1AdminUsersUserIdUpdateUser,
  adminPostApiV1AdminUsersUserIdActivateActivateUser,
  adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser,
  adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword,
  smsPostApiV1SmsSendSendSingleSms,
  smsPostApiV1SmsSendBulkSendBulkSms,
  applicationGetApiV1SmsBalanceCheckBalance,
  webhookPostApiV1DeliveryReportHandleDeliveryReport,
  smsGetApiV1SmsStatusMessageIdGetMessageStatus,
  apiGetRootRoot2,
  readyReadyGet,
  getModelsApiV1ModelsGroqGet,
  getOpenaiModelsApiV1ModelsOpenaiGet,
  chatApiV1ChatPost,
  getChatHistoryApiV1ChatSessionIdSessionGet,
  getChatSessionsApiV1ChatSessionsAllGet,
  queryRagApiV1RagQueryPost,
  uploadForRagApiV1RagUploadPost,
  speechToTextApiV1SpitchSpeechToTextPost,
  textToSpeechApiV1SpitchTextToSpeechPost,
  translateApiV1SpitchTranslatePost,
  rootGet,
  dpiApiPostApiV1NinLookupNinLookup,
  dpiApiPostApiV1BvnLookupBvnLookup,
  dpiApiPostApiV1CreditScoreCreditScore,
  dpiApiPostApiV1SelfieVerificationNinSelfieVerificationNin,
  apiGetRootRoot3,
  getNearbyPlacesApiV1MapsNearbyGet,
  getDistanceApiV1MapsDistanceGet,
  getDirectionsApiV1MapsDirectionsGet,
  getStaticMapApiV1MapsStaticGet,
  getRouteApiV1MapsRoutesPost,
  apiGetRootRoot4,
  apiPostUssdUssdProxy,
  apiPostUssdNotificationUssdNotification,
  ussdPostApiV18MedicalUssdCallback8Medical,
  ussdPostApiV1AlajoUssdCallbackAlajo,
  ussdPostApiV1ClafiyaUssdCallbackClafiya,
  ussdPostApiV1EvetUssdCallbackEvet,
  ussdPostApiV1FertitudeUssdCallbackFertitude,
  ussdPostApiV1FologUssdCallbackFolog,
  ussdPostApiV1MylturaUssdCallbackMyltura,
  ussdPostApiV1UhcTechUssdCallbackUhcTech,
  ussdPostApiV1XboxUssdCallbackXbox,
  ussdPostApiV1TestFertitudeUssdTestFertitudeUssd,
  ussdPostApiV1Test8MedicalUssdTest8MedicalUssd,
  ussdPostApiV1TestAlajoUssdTestAlajoUssd,
  ussdPostApiV1TestClafiyaUssdTestClafiyaUssd,
  ussdPostApiV1TestEvetUssdTestEvetUssd,
  ussdPostApiV1TestFologUssdTestFologUssd,
  ussdPostApiV1TestMylturaUssdTestMylturaUssd,
  ussdPostApiV1TestUhcTechUssdTestUhcTechUssd,
  ussdPostApiV1TestXboxUssdTestXboxUssd,
  apiGetMetricsMetrics,
  apiGetHealthHealthCheck,
  apiGetRootRoot5,
  authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2,
  authenticationGetApiV1AuthWellKnownJwksJsonJwks2,
  authenticationPostApiV1AuthLoginLoginUser2,
  authenticationPostApiV1AuthLoginJsonLoginUserJson2,
  authenticationGetApiV1AuthMeReadUserMe2,
  authenticationPostApiV1AuthLogoutLogoutUser2,
  oauth2PostApiV1Oauth2ClientsCreateOauthClient2,
  oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2,
  oauth2GetApiV1Oauth2AuthorizeAuthorize2,
  oauth2PostApiV1Oauth2TokenGetToken2,
  adminGetApiV1AdminUsersListUsers2,
  adminPostApiV1AdminUsersCreateUser2,
  adminDeleteApiV1AdminUsersUserIdDeleteUser2,
  adminGetApiV1AdminUsersUserIdGetUser2,
  adminPutApiV1AdminUsersUserIdUpdateUser2,
  adminPostApiV1AdminUsersUserIdActivateActivateUser2,
  adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2,
  adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2,
  healthGetApiV1HealthHealthCheck,
  smsPostApiV1SmsSendSendSingleSms2,
  smsPostApiV1SmsSendBulkSendBulkSms2,
  applicationGetApiV1SmsBalanceCheckBalance2,
  webhookPostApiV1DeliveryReportHandleDeliveryReport2,
  smsGetApiV1SmsStatusMessageIdGetMessageStatus2,
  apiGetHealthHealthCheck2,
  apiGetRootRoot6,
  apiGetMetricsMetrics2,
  healthHealthGet,
  readyReadyGet2,
  getModelsApiV1ModelsGroqGet2,
  getOpenaiModelsApiV1ModelsOpenaiGet2,
  chatApiV1ChatPost2,
  getChatHistoryApiV1ChatSessionIdSessionGet2,
  getChatSessionsApiV1ChatSessionsAllGet2,
  queryRagApiV1RagQueryPost2,
  uploadForRagApiV1RagUploadPost2,
  speechToTextApiV1SpitchSpeechToTextPost2,
  textToSpeechApiV1SpitchTextToSpeechPost2,
  translateApiV1SpitchTranslatePost2,
  rootGet2,
  metricsMetricsGet,
  getNearbyPlacesApiV1MapsNearbyGet2,
  getDistanceApiV1MapsDistanceGet2,
  getDirectionsApiV1MapsDirectionsGet2,
  getStaticMapApiV1MapsStaticGet2,
  getRouteApiV1MapsRoutesPost2,
  healthCheckHealthGet,
  metricsMetricsGet2,
  apiGetHealthHealthCheck3,
  apiPostUssdUssdProxy2,
  apiPostUssdNotificationUssdNotification2,
  ussdPostApiV18MedicalUssdCallback8Medical2,
  ussdPostApiV1AlajoUssdCallbackAlajo2,
  ussdPostApiV1ClafiyaUssdCallbackClafiya2,
  ussdPostApiV1EvetUssdCallbackEvet2,
  ussdPostApiV1FertitudeUssdCallbackFertitude2,
  ussdPostApiV1FologUssdCallbackFolog2,
  ussdPostApiV1MylturaUssdCallbackMyltura2,
  ussdPostApiV1UhcTechUssdCallbackUhcTech2,
  ussdPostApiV1XboxUssdCallbackXbox2,
  ussdPostApiV1TestFertitudeUssdTestFertitudeUssd2,
  ussdPostApiV1Test8MedicalUssdTest8MedicalUssd2,
  ussdPostApiV1TestAlajoUssdTestAlajoUssd2,
  ussdPostApiV1TestClafiyaUssdTestClafiyaUssd2,
  ussdPostApiV1TestEvetUssdTestEvetUssd2,
  ussdPostApiV1TestFologUssdTestFologUssd2,
  ussdPostApiV1TestMylturaUssdTestMylturaUssd2,
  ussdPostApiV1TestUhcTechUssdTestUhcTechUssd2,
  ussdPostApiV1TestXboxUssdTestXboxUssd2,
  apiGetMetricsMetrics3,
} from "../sdk.gen";
import {
  queryOptions,
  type UseMutationOptions,
  type DefaultError,
} from "@tanstack/react-query";
import type {
  DefaultHealthCheckData,
  DefaultRootData,
  DefaultGatewayHealthData,
  DefaultTestMetricsData,
  DefaultMetricsEndpointData,
  ApiGetRootRootData,
  AuthenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfigurationData,
  AuthenticationGetApiV1AuthWellKnownJwksJsonJwksData,
  AuthenticationPostApiV1AuthLoginLoginUserData,
  AuthenticationPostApiV1AuthLoginLoginUserError,
  AuthenticationPostApiV1AuthLoginLoginUserResponse,
  AuthenticationPostApiV1AuthLoginJsonLoginUserJsonData,
  AuthenticationPostApiV1AuthLoginJsonLoginUserJsonError,
  AuthenticationPostApiV1AuthLoginJsonLoginUserJsonResponse,
  AuthenticationGetApiV1AuthMeReadUserMeData,
  AuthenticationPostApiV1AuthLogoutLogoutUserData,
  Oauth2PostApiV1Oauth2ClientsCreateOauthClientData,
  Oauth2PostApiV1Oauth2ClientsCreateOauthClientError,
  Oauth2PostApiV1Oauth2ClientsCreateOauthClientResponse,
  Oauth2GetApiV1Oauth2ClientsClientIdGetOauthClientData,
  Oauth2GetApiV1Oauth2AuthorizeAuthorizeData,
  Oauth2PostApiV1Oauth2TokenGetTokenData,
  Oauth2PostApiV1Oauth2TokenGetTokenError,
  Oauth2PostApiV1Oauth2TokenGetTokenResponse,
  AdminGetApiV1AdminUsersListUsersData,
  AdminPostApiV1AdminUsersCreateUserData,
  AdminPostApiV1AdminUsersCreateUserError,
  AdminPostApiV1AdminUsersCreateUserResponse,
  AdminDeleteApiV1AdminUsersUserIdDeleteUserData,
  AdminDeleteApiV1AdminUsersUserIdDeleteUserError,
  AdminGetApiV1AdminUsersUserIdGetUserData,
  AdminPutApiV1AdminUsersUserIdUpdateUserData,
  AdminPutApiV1AdminUsersUserIdUpdateUserError,
  AdminPutApiV1AdminUsersUserIdUpdateUserResponse,
  AdminPostApiV1AdminUsersUserIdActivateActivateUserData,
  AdminPostApiV1AdminUsersUserIdActivateActivateUserError,
  AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserData,
  AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserError,
  AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordData,
  AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordError,
  SmsPostApiV1SmsSendSendSingleSmsData,
  SmsPostApiV1SmsSendSendSingleSmsError,
  SmsPostApiV1SmsSendBulkSendBulkSmsData,
  SmsPostApiV1SmsSendBulkSendBulkSmsError,
  ApplicationGetApiV1SmsBalanceCheckBalanceData,
  WebhookPostApiV1DeliveryReportHandleDeliveryReportData,
  SmsGetApiV1SmsStatusMessageIdGetMessageStatusData,
  ApiGetRootRoot2Data,
  ReadyReadyGetData,
  GetModelsApiV1ModelsGroqGetData,
  GetOpenaiModelsApiV1ModelsOpenaiGetData,
  ChatApiV1ChatPostData,
  ChatApiV1ChatPostError,
  ChatApiV1ChatPostResponse,
  GetChatHistoryApiV1ChatSessionIdSessionGetData,
  GetChatSessionsApiV1ChatSessionsAllGetData,
  QueryRagApiV1RagQueryPostData,
  QueryRagApiV1RagQueryPostError,
  QueryRagApiV1RagQueryPostResponse,
  UploadForRagApiV1RagUploadPostData,
  UploadForRagApiV1RagUploadPostError,
  UploadForRagApiV1RagUploadPostResponse,
  SpeechToTextApiV1SpitchSpeechToTextPostData,
  SpeechToTextApiV1SpitchSpeechToTextPostError,
  TextToSpeechApiV1SpitchTextToSpeechPostData,
  TextToSpeechApiV1SpitchTextToSpeechPostError,
  TranslateApiV1SpitchTranslatePostData,
  TranslateApiV1SpitchTranslatePostError,
  RootGetData,
  DpiApiPostApiV1NinLookupNinLookupData,
  DpiApiPostApiV1NinLookupNinLookupError,
  DpiApiPostApiV1NinLookupNinLookupResponse,
  DpiApiPostApiV1BvnLookupBvnLookupData,
  DpiApiPostApiV1BvnLookupBvnLookupError,
  DpiApiPostApiV1BvnLookupBvnLookupResponse,
  DpiApiPostApiV1CreditScoreCreditScoreData,
  DpiApiPostApiV1CreditScoreCreditScoreError,
  DpiApiPostApiV1CreditScoreCreditScoreResponse,
  DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinData,
  DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinError,
  DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinResponse,
  ApiGetRootRoot3Data,
  GetNearbyPlacesApiV1MapsNearbyGetData,
  GetDistanceApiV1MapsDistanceGetData,
  GetDirectionsApiV1MapsDirectionsGetData,
  GetStaticMapApiV1MapsStaticGetData,
  GetRouteApiV1MapsRoutesPostData,
  GetRouteApiV1MapsRoutesPostError,
  ApiGetRootRoot4Data,
  ApiPostUssdUssdProxyData,
  ApiPostUssdUssdProxyError,
  ApiPostUssdNotificationUssdNotificationData,
  ApiPostUssdNotificationUssdNotificationError,
  UssdPostApiV18MedicalUssdCallback8MedicalData,
  UssdPostApiV1AlajoUssdCallbackAlajoData,
  UssdPostApiV1ClafiyaUssdCallbackClafiyaData,
  UssdPostApiV1EvetUssdCallbackEvetData,
  UssdPostApiV1FertitudeUssdCallbackFertitudeData,
  UssdPostApiV1FologUssdCallbackFologData,
  UssdPostApiV1MylturaUssdCallbackMylturaData,
  UssdPostApiV1UhcTechUssdCallbackUhcTechData,
  UssdPostApiV1XboxUssdCallbackXboxData,
  UssdPostApiV1TestFertitudeUssdTestFertitudeUssdData,
  UssdPostApiV1TestFertitudeUssdTestFertitudeUssdError,
  UssdPostApiV1Test8MedicalUssdTest8MedicalUssdData,
  UssdPostApiV1Test8MedicalUssdTest8MedicalUssdError,
  UssdPostApiV1TestAlajoUssdTestAlajoUssdData,
  UssdPostApiV1TestAlajoUssdTestAlajoUssdError,
  UssdPostApiV1TestClafiyaUssdTestClafiyaUssdData,
  UssdPostApiV1TestClafiyaUssdTestClafiyaUssdError,
  UssdPostApiV1TestEvetUssdTestEvetUssdData,
  UssdPostApiV1TestEvetUssdTestEvetUssdError,
  UssdPostApiV1TestFologUssdTestFologUssdData,
  UssdPostApiV1TestFologUssdTestFologUssdError,
  UssdPostApiV1TestMylturaUssdTestMylturaUssdData,
  UssdPostApiV1TestMylturaUssdTestMylturaUssdError,
  UssdPostApiV1TestUhcTechUssdTestUhcTechUssdData,
  UssdPostApiV1TestUhcTechUssdTestUhcTechUssdError,
  UssdPostApiV1TestXboxUssdTestXboxUssdData,
  UssdPostApiV1TestXboxUssdTestXboxUssdError,
  ApiGetMetricsMetricsData,
  ApiGetHealthHealthCheckData,
  ApiGetRootRoot5Data,
  AuthenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2Data,
  AuthenticationGetApiV1AuthWellKnownJwksJsonJwks2Data,
  AuthenticationPostApiV1AuthLoginLoginUser2Data,
  AuthenticationPostApiV1AuthLoginLoginUser2Error,
  AuthenticationPostApiV1AuthLoginLoginUser2Response,
  AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Data,
  AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Error,
  AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Response,
  AuthenticationGetApiV1AuthMeReadUserMe2Data,
  AuthenticationPostApiV1AuthLogoutLogoutUser2Data,
  Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Data,
  Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Error,
  Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Response,
  Oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2Data,
  Oauth2GetApiV1Oauth2AuthorizeAuthorize2Data,
  Oauth2PostApiV1Oauth2TokenGetToken2Data,
  Oauth2PostApiV1Oauth2TokenGetToken2Error,
  Oauth2PostApiV1Oauth2TokenGetToken2Response,
  AdminGetApiV1AdminUsersListUsers2Data,
  AdminPostApiV1AdminUsersCreateUser2Data,
  AdminPostApiV1AdminUsersCreateUser2Error,
  AdminPostApiV1AdminUsersCreateUser2Response,
  AdminDeleteApiV1AdminUsersUserIdDeleteUser2Data,
  AdminDeleteApiV1AdminUsersUserIdDeleteUser2Error,
  AdminGetApiV1AdminUsersUserIdGetUser2Data,
  AdminPutApiV1AdminUsersUserIdUpdateUser2Data,
  AdminPutApiV1AdminUsersUserIdUpdateUser2Error,
  AdminPutApiV1AdminUsersUserIdUpdateUser2Response,
  AdminPostApiV1AdminUsersUserIdActivateActivateUser2Data,
  AdminPostApiV1AdminUsersUserIdActivateActivateUser2Error,
  AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Data,
  AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Error,
  AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Data,
  AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Error,
  HealthGetApiV1HealthHealthCheckData,
  SmsPostApiV1SmsSendSendSingleSms2Data,
  SmsPostApiV1SmsSendSendSingleSms2Error,
  SmsPostApiV1SmsSendBulkSendBulkSms2Data,
  SmsPostApiV1SmsSendBulkSendBulkSms2Error,
  ApplicationGetApiV1SmsBalanceCheckBalance2Data,
  WebhookPostApiV1DeliveryReportHandleDeliveryReport2Data,
  SmsGetApiV1SmsStatusMessageIdGetMessageStatus2Data,
  ApiGetHealthHealthCheck2Data,
  ApiGetRootRoot6Data,
  ApiGetMetricsMetrics2Data,
  HealthHealthGetData,
  ReadyReadyGet2Data,
  GetModelsApiV1ModelsGroqGet2Data,
  GetOpenaiModelsApiV1ModelsOpenaiGet2Data,
  ChatApiV1ChatPost2Data,
  ChatApiV1ChatPost2Error,
  ChatApiV1ChatPost2Response,
  GetChatHistoryApiV1ChatSessionIdSessionGet2Data,
  GetChatSessionsApiV1ChatSessionsAllGet2Data,
  QueryRagApiV1RagQueryPost2Data,
  QueryRagApiV1RagQueryPost2Error,
  QueryRagApiV1RagQueryPost2Response,
  UploadForRagApiV1RagUploadPost2Data,
  UploadForRagApiV1RagUploadPost2Error,
  UploadForRagApiV1RagUploadPost2Response,
  SpeechToTextApiV1SpitchSpeechToTextPost2Data,
  SpeechToTextApiV1SpitchSpeechToTextPost2Error,
  TextToSpeechApiV1SpitchTextToSpeechPost2Data,
  TextToSpeechApiV1SpitchTextToSpeechPost2Error,
  TranslateApiV1SpitchTranslatePost2Data,
  TranslateApiV1SpitchTranslatePost2Error,
  RootGet2Data,
  MetricsMetricsGetData,
  GetNearbyPlacesApiV1MapsNearbyGet2Data,
  GetDistanceApiV1MapsDistanceGet2Data,
  GetDirectionsApiV1MapsDirectionsGet2Data,
  GetStaticMapApiV1MapsStaticGet2Data,
  GetRouteApiV1MapsRoutesPost2Data,
  GetRouteApiV1MapsRoutesPost2Error,
  HealthCheckHealthGetData,
  MetricsMetricsGet2Data,
  ApiGetHealthHealthCheck3Data,
  ApiPostUssdUssdProxy2Data,
  ApiPostUssdUssdProxy2Error,
  ApiPostUssdNotificationUssdNotification2Data,
  ApiPostUssdNotificationUssdNotification2Error,
  UssdPostApiV18MedicalUssdCallback8Medical2Data,
  UssdPostApiV1AlajoUssdCallbackAlajo2Data,
  UssdPostApiV1ClafiyaUssdCallbackClafiya2Data,
  UssdPostApiV1EvetUssdCallbackEvet2Data,
  UssdPostApiV1FertitudeUssdCallbackFertitude2Data,
  UssdPostApiV1FologUssdCallbackFolog2Data,
  UssdPostApiV1MylturaUssdCallbackMyltura2Data,
  UssdPostApiV1UhcTechUssdCallbackUhcTech2Data,
  UssdPostApiV1XboxUssdCallbackXbox2Data,
  UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Data,
  UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Error,
  UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Data,
  UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Error,
  UssdPostApiV1TestAlajoUssdTestAlajoUssd2Data,
  UssdPostApiV1TestAlajoUssdTestAlajoUssd2Error,
  UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Data,
  UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Error,
  UssdPostApiV1TestEvetUssdTestEvetUssd2Data,
  UssdPostApiV1TestEvetUssdTestEvetUssd2Error,
  UssdPostApiV1TestFologUssdTestFologUssd2Data,
  UssdPostApiV1TestFologUssdTestFologUssd2Error,
  UssdPostApiV1TestMylturaUssdTestMylturaUssd2Data,
  UssdPostApiV1TestMylturaUssdTestMylturaUssd2Error,
  UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Data,
  UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Error,
  UssdPostApiV1TestXboxUssdTestXboxUssd2Data,
  UssdPostApiV1TestXboxUssdTestXboxUssd2Error,
  ApiGetMetricsMetrics3Data,
} from "../types.gen";
import { client as _heyApiClient } from "../client.gen";

export type QueryKey<TOptions extends Options> = [
  Pick<TOptions, "baseUrl" | "body" | "headers" | "path" | "query"> & {
    _id: string;
    _infinite?: boolean;
    tags?: readonly string[];
  },
];

const createQueryKey = <TOptions extends Options>(
  id: string,
  options?: TOptions,
  infinite?: boolean,
  tags?: readonly string[]
): [QueryKey<TOptions>[0]] => {
  const params: QueryKey<TOptions>[0] = {
    _id: id,
    baseUrl:
      options?.baseUrl ||
      (options?.client ?? _heyApiClient).getConfig().baseUrl,
  } as QueryKey<TOptions>[0];
  if (infinite) {
    params._infinite = infinite;
  }
  if (tags) {
    params.tags = tags;
  }
  if (options?.body) {
    params.body = options.body;
  }
  if (options?.headers) {
    params.headers = options.headers;
  }
  if (options?.path) {
    params.path = options.path;
  }
  if (options?.query) {
    params.query = options.query;
  }
  return [params];
};

export const defaultHealthCheckQueryKey = (
  options?: Options<DefaultHealthCheckData>
) => createQueryKey("defaultHealthCheck", options);

/**
 * Health Check
 * Health check endpoint
 */
export const defaultHealthCheckOptions = (
  options?: Options<DefaultHealthCheckData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await defaultHealthCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: defaultHealthCheckQueryKey(options),
  });
};

export const defaultRootQueryKey = (options?: Options<DefaultRootData>) =>
  createQueryKey("defaultRoot", options);

/**
 * Root
 * Root endpoint
 */
export const defaultRootOptions = (options?: Options<DefaultRootData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await defaultRoot({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: defaultRootQueryKey(options),
  });
};

export const defaultGatewayHealthQueryKey = (
  options?: Options<DefaultGatewayHealthData>
) => createQueryKey("defaultGatewayHealth", options);

/**
 * Gateway Health
 * Gateway health check
 */
export const defaultGatewayHealthOptions = (
  options?: Options<DefaultGatewayHealthData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await defaultGatewayHealth({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: defaultGatewayHealthQueryKey(options),
  });
};

export const defaultTestMetricsQueryKey = (
  options?: Options<DefaultTestMetricsData>
) => createQueryKey("defaultTestMetrics", options);

/**
 * Test Metrics
 * Test endpoint to verify prometheus client is working
 */
export const defaultTestMetricsOptions = (
  options?: Options<DefaultTestMetricsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await defaultTestMetrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: defaultTestMetricsQueryKey(options),
  });
};

export const defaultMetricsEndpointQueryKey = (
  options?: Options<DefaultMetricsEndpointData>
) => createQueryKey("defaultMetricsEndpoint", options);

/**
 * Metrics Endpoint
 * Prometheus metrics endpoint with comprehensive API Gateway metrics
 */
export const defaultMetricsEndpointOptions = (
  options?: Options<DefaultMetricsEndpointData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await defaultMetricsEndpoint({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: defaultMetricsEndpointQueryKey(options),
  });
};

export const apiGetRootRootQueryKey = (options?: Options<ApiGetRootRootData>) =>
  createQueryKey("apiGetRootRoot", options);

/**
 * Root
 * Root endpoint.
 */
export const apiGetRootRootOptions = (
  options?: Options<ApiGetRootRootData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetRootRoot({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetRootRootQueryKey(options),
  });
};

export const authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfigurationQueryKey =
  (
    options?: Options<AuthenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfigurationData>
  ) =>
    createQueryKey(
      "authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration",
      options
    );

/**
 * Openid Configuration
 * üîç OpenID Connect Configuration
 *
 * Standard OpenID Connect discovery endpoint providing
 * metadata about the authorization server.
 *
 * **Returns:**
 * - Issuer information
 * - Supported endpoints
 * - Token types and algorithms
 * - Grant types supported
 *
 * **Compliance:**
 * - OpenID Connect Discovery 1.0
 * - OAuth 2.0 Authorization Server Metadata
 */
export const authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfigurationOptions =
  (
    options?: Options<AuthenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfigurationData>
  ) => {
    return queryOptions({
      queryFn: async ({ queryKey, signal }) => {
        const { data } =
          await authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration(
            {
              ...options,
              ...queryKey[0],
              signal,
              throwOnError: true,
            }
          );
        return data;
      },
      queryKey:
        authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfigurationQueryKey(
          options
        ),
    });
  };

export const authenticationGetApiV1AuthWellKnownJwksJsonJwksQueryKey = (
  options?: Options<AuthenticationGetApiV1AuthWellKnownJwksJsonJwksData>
) => createQueryKey("authenticationGetApiV1AuthWellKnownJwksJsonJwks", options);

/**
 * Jwks
 * üîë JSON Web Key Set
 *
 * Provides public keys for JWT token verification.
 * Used by clients to validate JWT signatures.
 *
 * **Returns:**
 * - JSON Web Key Set (JWKS)
 * - Public key information
 * - Key usage and algorithms
 *
 * **Note:** Currently using HMAC (symmetric key)
 * For production, consider RSA/ECDSA asymmetric keys
 */
export const authenticationGetApiV1AuthWellKnownJwksJsonJwksOptions = (
  options?: Options<AuthenticationGetApiV1AuthWellKnownJwksJsonJwksData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationGetApiV1AuthWellKnownJwksJsonJwks({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticationGetApiV1AuthWellKnownJwksJsonJwksQueryKey(options),
  });
};

export const authenticationPostApiV1AuthLoginLoginUserQueryKey = (
  options: Options<AuthenticationPostApiV1AuthLoginLoginUserData>
) => createQueryKey("authenticationPostApiV1AuthLoginLoginUser", options);

/**
 * Login User
 * üîê OAuth2 Compatible Login
 *
 * Authenticate user with form data and return JWT tokens.
 * Compatible with OAuth2 password flow for API clients.
 *
 * **Request Format:**
 * - Content-Type: application/x-www-form-urlencoded
 * - username: Email or username
 * - password: User password
 *
 * **Response:**
 * - access_token: JWT token for API access
 * - refresh_token: Token for refreshing access
 * - token_type: "bearer"
 * - expires_in: Token expiration in seconds
 *
 * **Use Cases:**
 * - OAuth2 client applications
 * - API integrations requiring form-based auth
 * - Third-party service authentication
 */
export const authenticationPostApiV1AuthLoginLoginUserOptions = (
  options: Options<AuthenticationPostApiV1AuthLoginLoginUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationPostApiV1AuthLoginLoginUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticationPostApiV1AuthLoginLoginUserQueryKey(options),
  });
};

/**
 * Login User
 * üîê OAuth2 Compatible Login
 *
 * Authenticate user with form data and return JWT tokens.
 * Compatible with OAuth2 password flow for API clients.
 *
 * **Request Format:**
 * - Content-Type: application/x-www-form-urlencoded
 * - username: Email or username
 * - password: User password
 *
 * **Response:**
 * - access_token: JWT token for API access
 * - refresh_token: Token for refreshing access
 * - token_type: "bearer"
 * - expires_in: Token expiration in seconds
 *
 * **Use Cases:**
 * - OAuth2 client applications
 * - API integrations requiring form-based auth
 * - Third-party service authentication
 */
export const authenticationPostApiV1AuthLoginLoginUserMutation = (
  options?: Partial<Options<AuthenticationPostApiV1AuthLoginLoginUserData>>
): UseMutationOptions<
  AuthenticationPostApiV1AuthLoginLoginUserResponse,
  AuthenticationPostApiV1AuthLoginLoginUserError,
  Options<AuthenticationPostApiV1AuthLoginLoginUserData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthenticationPostApiV1AuthLoginLoginUserResponse,
    AuthenticationPostApiV1AuthLoginLoginUserError,
    Options<AuthenticationPostApiV1AuthLoginLoginUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authenticationPostApiV1AuthLoginLoginUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authenticationPostApiV1AuthLoginJsonLoginUserJsonQueryKey = (
  options: Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJsonData>
) =>
  createQueryKey("authenticationPostApiV1AuthLoginJsonLoginUserJson", options);

/**
 * Login User Json
 * üöÄ JSON Login for Nigerian Startups
 *
 * Primary login endpoint for Nigerian DPI developers.
 * Accepts JSON payload with email or username authentication.
 *
 * **Request Example:**
 * ```json
 * {
 * "identifier": "adebayo@fintech.ng",  // Email or username
 * "password": "SecurePass123"
 * }
 * ```
 *
 * **Features:**
 * - ‚úÖ Email or username login
 * - ‚úÖ JWT token generation
 * - ‚úÖ Last login tracking
 * - ‚úÖ Request correlation ID support
 *
 * **Nigerian Context:**
 * - Supports Nigerian email domains (.ng, .com.ng)
 * - Optimized for fintech and DPI applications
 * - Audit logging for regulatory compliance
 */
export const authenticationPostApiV1AuthLoginJsonLoginUserJsonOptions = (
  options: Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJsonData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationPostApiV1AuthLoginJsonLoginUserJson({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey:
      authenticationPostApiV1AuthLoginJsonLoginUserJsonQueryKey(options),
  });
};

/**
 * Login User Json
 * üöÄ JSON Login for Nigerian Startups
 *
 * Primary login endpoint for Nigerian DPI developers.
 * Accepts JSON payload with email or username authentication.
 *
 * **Request Example:**
 * ```json
 * {
 * "identifier": "adebayo@fintech.ng",  // Email or username
 * "password": "SecurePass123"
 * }
 * ```
 *
 * **Features:**
 * - ‚úÖ Email or username login
 * - ‚úÖ JWT token generation
 * - ‚úÖ Last login tracking
 * - ‚úÖ Request correlation ID support
 *
 * **Nigerian Context:**
 * - Supports Nigerian email domains (.ng, .com.ng)
 * - Optimized for fintech and DPI applications
 * - Audit logging for regulatory compliance
 */
export const authenticationPostApiV1AuthLoginJsonLoginUserJsonMutation = (
  options?: Partial<
    Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJsonData>
  >
): UseMutationOptions<
  AuthenticationPostApiV1AuthLoginJsonLoginUserJsonResponse,
  AuthenticationPostApiV1AuthLoginJsonLoginUserJsonError,
  Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJsonData>
> => {
  const mutationOptions: UseMutationOptions<
    AuthenticationPostApiV1AuthLoginJsonLoginUserJsonResponse,
    AuthenticationPostApiV1AuthLoginJsonLoginUserJsonError,
    Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJsonData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authenticationPostApiV1AuthLoginJsonLoginUserJson({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authenticationGetApiV1AuthMeReadUserMeQueryKey = (
  options?: Options<AuthenticationGetApiV1AuthMeReadUserMeData>
) => createQueryKey("authenticationGetApiV1AuthMeReadUserMe", options);

/**
 * Read User Me
 * üë§ Get Current User Profile
 *
 * Retrieve authenticated user's profile information.
 * Requires valid JWT token in Authorization header.
 *
 * **Headers Required:**
 * - Authorization: Bearer {access_token}
 *
 * **Returns:**
 * - User profile with Nigerian DPI context
 * - NIN/BVN verification status
 * - Account activity information
 *
 * **Security:**
 * - Token validation required
 * - Active user status check
 * - Soft-delete filtering applied
 */
export const authenticationGetApiV1AuthMeReadUserMeOptions = (
  options?: Options<AuthenticationGetApiV1AuthMeReadUserMeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationGetApiV1AuthMeReadUserMe({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticationGetApiV1AuthMeReadUserMeQueryKey(options),
  });
};

export const authenticationPostApiV1AuthLogoutLogoutUserQueryKey = (
  options?: Options<AuthenticationPostApiV1AuthLogoutLogoutUserData>
) => createQueryKey("authenticationPostApiV1AuthLogoutLogoutUser", options);

/**
 * Logout User
 * üö™ User Logout
 *
 * Logout current user session.
 * Client should remove tokens from storage.
 *
 * **Process:**
 * 1. Client receives logout confirmation
 * 2. Client removes access/refresh tokens
 * 3. Tokens become invalid on next request
 *
 * **Best Practice:**
 * - Clear all stored authentication data
 * - Redirect to login page
 * - Invalidate any cached user data
 *
 * **Note:** Server-side token blacklisting available
 * for enhanced security in production.
 */
export const authenticationPostApiV1AuthLogoutLogoutUserOptions = (
  options?: Options<AuthenticationPostApiV1AuthLogoutLogoutUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationPostApiV1AuthLogoutLogoutUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticationPostApiV1AuthLogoutLogoutUserQueryKey(options),
  });
};

/**
 * Logout User
 * üö™ User Logout
 *
 * Logout current user session.
 * Client should remove tokens from storage.
 *
 * **Process:**
 * 1. Client receives logout confirmation
 * 2. Client removes access/refresh tokens
 * 3. Tokens become invalid on next request
 *
 * **Best Practice:**
 * - Clear all stored authentication data
 * - Redirect to login page
 * - Invalidate any cached user data
 *
 * **Note:** Server-side token blacklisting available
 * for enhanced security in production.
 */
export const authenticationPostApiV1AuthLogoutLogoutUserMutation = (
  options?: Partial<Options<AuthenticationPostApiV1AuthLogoutLogoutUserData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<AuthenticationPostApiV1AuthLogoutLogoutUserData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AuthenticationPostApiV1AuthLogoutLogoutUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authenticationPostApiV1AuthLogoutLogoutUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oauth2PostApiV1Oauth2ClientsCreateOauthClientQueryKey = (
  options: Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClientData>
) => createQueryKey("oauth2PostApiV1Oauth2ClientsCreateOauthClient", options);

/**
 * Create Oauth Client
 * Create a new OAuth2 client.
 */
export const oauth2PostApiV1Oauth2ClientsCreateOauthClientOptions = (
  options: Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClientData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauth2PostApiV1Oauth2ClientsCreateOauthClient({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauth2PostApiV1Oauth2ClientsCreateOauthClientQueryKey(options),
  });
};

/**
 * Create Oauth Client
 * Create a new OAuth2 client.
 */
export const oauth2PostApiV1Oauth2ClientsCreateOauthClientMutation = (
  options?: Partial<Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClientData>>
): UseMutationOptions<
  Oauth2PostApiV1Oauth2ClientsCreateOauthClientResponse,
  Oauth2PostApiV1Oauth2ClientsCreateOauthClientError,
  Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClientData>
> => {
  const mutationOptions: UseMutationOptions<
    Oauth2PostApiV1Oauth2ClientsCreateOauthClientResponse,
    Oauth2PostApiV1Oauth2ClientsCreateOauthClientError,
    Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClientData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await oauth2PostApiV1Oauth2ClientsCreateOauthClient({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oauth2GetApiV1Oauth2ClientsClientIdGetOauthClientQueryKey = (
  options: Options<Oauth2GetApiV1Oauth2ClientsClientIdGetOauthClientData>
) =>
  createQueryKey("oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient", options);

/**
 * Get Oauth Client
 * Get OAuth2 client by ID.
 */
export const oauth2GetApiV1Oauth2ClientsClientIdGetOauthClientOptions = (
  options: Options<Oauth2GetApiV1Oauth2ClientsClientIdGetOauthClientData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey:
      oauth2GetApiV1Oauth2ClientsClientIdGetOauthClientQueryKey(options),
  });
};

export const oauth2GetApiV1Oauth2AuthorizeAuthorizeQueryKey = (
  options: Options<Oauth2GetApiV1Oauth2AuthorizeAuthorizeData>
) => createQueryKey("oauth2GetApiV1Oauth2AuthorizeAuthorize", options);

/**
 * Authorize
 * OAuth2 authorization endpoint.
 */
export const oauth2GetApiV1Oauth2AuthorizeAuthorizeOptions = (
  options: Options<Oauth2GetApiV1Oauth2AuthorizeAuthorizeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauth2GetApiV1Oauth2AuthorizeAuthorize({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauth2GetApiV1Oauth2AuthorizeAuthorizeQueryKey(options),
  });
};

export const oauth2PostApiV1Oauth2TokenGetTokenQueryKey = (
  options: Options<Oauth2PostApiV1Oauth2TokenGetTokenData>
) => createQueryKey("oauth2PostApiV1Oauth2TokenGetToken", options);

/**
 * Get Token
 * OAuth2 token endpoint.
 */
export const oauth2PostApiV1Oauth2TokenGetTokenOptions = (
  options: Options<Oauth2PostApiV1Oauth2TokenGetTokenData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauth2PostApiV1Oauth2TokenGetToken({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauth2PostApiV1Oauth2TokenGetTokenQueryKey(options),
  });
};

/**
 * Get Token
 * OAuth2 token endpoint.
 */
export const oauth2PostApiV1Oauth2TokenGetTokenMutation = (
  options?: Partial<Options<Oauth2PostApiV1Oauth2TokenGetTokenData>>
): UseMutationOptions<
  Oauth2PostApiV1Oauth2TokenGetTokenResponse,
  Oauth2PostApiV1Oauth2TokenGetTokenError,
  Options<Oauth2PostApiV1Oauth2TokenGetTokenData>
> => {
  const mutationOptions: UseMutationOptions<
    Oauth2PostApiV1Oauth2TokenGetTokenResponse,
    Oauth2PostApiV1Oauth2TokenGetTokenError,
    Options<Oauth2PostApiV1Oauth2TokenGetTokenData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await oauth2PostApiV1Oauth2TokenGetToken({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const adminGetApiV1AdminUsersListUsersQueryKey = (
  options?: Options<AdminGetApiV1AdminUsersListUsersData>
) => createQueryKey("adminGetApiV1AdminUsersListUsers", options);

/**
 * List Users
 * üìÑ List All Nigerian Startup Users
 *
 * Retrieve paginated list of all registered users.
 * Includes verification status and activity metrics.
 *
 * **Query Parameters:**
 * - skip: Number of records to skip (default: 0)
 * - limit: Maximum records to return (default: 100)
 *
 * **Response Includes:**
 * - User profiles with NIN/BVN status
 * - Last login and activity data
 * - Account verification levels
 * - Soft-delete filtering applied
 *
 * **Admin Only:** Platform oversight and user management
 */
export const adminGetApiV1AdminUsersListUsersOptions = (
  options?: Options<AdminGetApiV1AdminUsersListUsersData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await adminGetApiV1AdminUsersListUsers({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: adminGetApiV1AdminUsersListUsersQueryKey(options),
  });
};

export const adminPostApiV1AdminUsersCreateUserQueryKey = (
  options: Options<AdminPostApiV1AdminUsersCreateUserData>
) => createQueryKey("adminPostApiV1AdminUsersCreateUser", options);

/**
 * Create User
 * üë• Create Nigerian Startup Account
 *
 * Create new user account for Nigerian DPI developers.
 * Only accessible by platform administrators.
 *
 * **Request Example:**
 * ```json
 * {
 * "email": "developer@fintech.ng",
 * "username": "fintech_dev",
 * "password": "TempPass123",
 * "first_name": "Adebayo",
 * "last_name": "Ogundimu",
 * "role": "developer"  // Optional: admin, developer
 * }
 * ```
 *
 * **Features:**
 * - ‚úÖ Email uniqueness validation
 * - ‚úÖ Username availability check
 * - ‚úÖ Automatic welcome email
 * - ‚úÖ Nigerian domain support (.ng, .com.ng)
 *
 * **Admin Access Required:**
 * - Must be authenticated as admin
 * - Closed sandbox: Only 9 Nigerian startups
 */
export const adminPostApiV1AdminUsersCreateUserOptions = (
  options: Options<AdminPostApiV1AdminUsersCreateUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await adminPostApiV1AdminUsersCreateUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: adminPostApiV1AdminUsersCreateUserQueryKey(options),
  });
};

/**
 * Create User
 * üë• Create Nigerian Startup Account
 *
 * Create new user account for Nigerian DPI developers.
 * Only accessible by platform administrators.
 *
 * **Request Example:**
 * ```json
 * {
 * "email": "developer@fintech.ng",
 * "username": "fintech_dev",
 * "password": "TempPass123",
 * "first_name": "Adebayo",
 * "last_name": "Ogundimu",
 * "role": "developer"  // Optional: admin, developer
 * }
 * ```
 *
 * **Features:**
 * - ‚úÖ Email uniqueness validation
 * - ‚úÖ Username availability check
 * - ‚úÖ Automatic welcome email
 * - ‚úÖ Nigerian domain support (.ng, .com.ng)
 *
 * **Admin Access Required:**
 * - Must be authenticated as admin
 * - Closed sandbox: Only 9 Nigerian startups
 */
export const adminPostApiV1AdminUsersCreateUserMutation = (
  options?: Partial<Options<AdminPostApiV1AdminUsersCreateUserData>>
): UseMutationOptions<
  AdminPostApiV1AdminUsersCreateUserResponse,
  AdminPostApiV1AdminUsersCreateUserError,
  Options<AdminPostApiV1AdminUsersCreateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    AdminPostApiV1AdminUsersCreateUserResponse,
    AdminPostApiV1AdminUsersCreateUserError,
    Options<AdminPostApiV1AdminUsersCreateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await adminPostApiV1AdminUsersCreateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete User
 * üóëÔ∏è Soft Delete User Account
 *
 * Mark user account as deleted (soft delete).
 * Preserves data for audit compliance.
 *
 * **Process:**
 * 1. Sets is_deleted = true
 * 2. Records deletion timestamp
 * 3. Maintains audit trail
 * 4. Frees email/username for reuse
 *
 * **Data Retention:**
 * - User data preserved for compliance
 * - API access immediately revoked
 * - Email/username become available
 *
 * **NDPR Compliant:** Nigerian Data Protection Regulation
 */
export const adminDeleteApiV1AdminUsersUserIdDeleteUserMutation = (
  options?: Partial<Options<AdminDeleteApiV1AdminUsersUserIdDeleteUserData>>
): UseMutationOptions<
  unknown,
  AdminDeleteApiV1AdminUsersUserIdDeleteUserError,
  Options<AdminDeleteApiV1AdminUsersUserIdDeleteUserData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AdminDeleteApiV1AdminUsersUserIdDeleteUserError,
    Options<AdminDeleteApiV1AdminUsersUserIdDeleteUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await adminDeleteApiV1AdminUsersUserIdDeleteUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const adminGetApiV1AdminUsersUserIdGetUserQueryKey = (
  options: Options<AdminGetApiV1AdminUsersUserIdGetUserData>
) => createQueryKey("adminGetApiV1AdminUsersUserIdGetUser", options);

/**
 * Get User
 * üîç Get Specific User Details
 *
 * Retrieve detailed information for a specific user.
 * Includes full profile and verification status.
 *
 * **Path Parameters:**
 * - user_id: Unique user identifier
 *
 * **Returns:**
 * - Complete user profile
 * - NIN/BVN verification status
 * - Account activity history
 * - Role and permissions
 *
 * **Use Cases:**
 * - User support and troubleshooting
 * - Account verification review
 * - Compliance auditing
 */
export const adminGetApiV1AdminUsersUserIdGetUserOptions = (
  options: Options<AdminGetApiV1AdminUsersUserIdGetUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await adminGetApiV1AdminUsersUserIdGetUser({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: adminGetApiV1AdminUsersUserIdGetUserQueryKey(options),
  });
};

/**
 * Update User
 * ‚úèÔ∏è Update User Profile
 *
 * Modify user account information and settings.
 * Supports partial updates with validation.
 *
 * **Updatable Fields:**
 * - first_name, last_name
 * - email (with uniqueness check)
 * - username (with availability check)
 * - role (admin, developer)
 * - is_active status
 *
 * **Validation:**
 * - Email format and domain validation
 * - Username uniqueness across platform
 * - Role permission verification
 *
 * **Audit Trail:** All changes logged for compliance
 */
export const adminPutApiV1AdminUsersUserIdUpdateUserMutation = (
  options?: Partial<Options<AdminPutApiV1AdminUsersUserIdUpdateUserData>>
): UseMutationOptions<
  AdminPutApiV1AdminUsersUserIdUpdateUserResponse,
  AdminPutApiV1AdminUsersUserIdUpdateUserError,
  Options<AdminPutApiV1AdminUsersUserIdUpdateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    AdminPutApiV1AdminUsersUserIdUpdateUserResponse,
    AdminPutApiV1AdminUsersUserIdUpdateUserError,
    Options<AdminPutApiV1AdminUsersUserIdUpdateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await adminPutApiV1AdminUsersUserIdUpdateUser({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const adminPostApiV1AdminUsersUserIdActivateActivateUserQueryKey = (
  options: Options<AdminPostApiV1AdminUsersUserIdActivateActivateUserData>
) =>
  createQueryKey("adminPostApiV1AdminUsersUserIdActivateActivateUser", options);

/**
 * Activate User
 * ‚úÖ Activate User Account
 *
 * Enable user account for API access.
 * Restores full platform functionality.
 *
 * **Effects:**
 * - Enables login and API access
 * - Restores DPI service usage
 * - Allows NIN/BVN verification
 * - Resumes audit logging
 *
 * **Use Cases:**
 * - New account activation
 * - Account restoration after suspension
 * - Startup onboarding completion
 *
 * **Notification:** User receives activation email
 */
export const adminPostApiV1AdminUsersUserIdActivateActivateUserOptions = (
  options: Options<AdminPostApiV1AdminUsersUserIdActivateActivateUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await adminPostApiV1AdminUsersUserIdActivateActivateUser(
        {
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        }
      );
      return data;
    },
    queryKey:
      adminPostApiV1AdminUsersUserIdActivateActivateUserQueryKey(options),
  });
};

/**
 * Activate User
 * ‚úÖ Activate User Account
 *
 * Enable user account for API access.
 * Restores full platform functionality.
 *
 * **Effects:**
 * - Enables login and API access
 * - Restores DPI service usage
 * - Allows NIN/BVN verification
 * - Resumes audit logging
 *
 * **Use Cases:**
 * - New account activation
 * - Account restoration after suspension
 * - Startup onboarding completion
 *
 * **Notification:** User receives activation email
 */
export const adminPostApiV1AdminUsersUserIdActivateActivateUserMutation = (
  options?: Partial<
    Options<AdminPostApiV1AdminUsersUserIdActivateActivateUserData>
  >
): UseMutationOptions<
  unknown,
  AdminPostApiV1AdminUsersUserIdActivateActivateUserError,
  Options<AdminPostApiV1AdminUsersUserIdActivateActivateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AdminPostApiV1AdminUsersUserIdActivateActivateUserError,
    Options<AdminPostApiV1AdminUsersUserIdActivateActivateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await adminPostApiV1AdminUsersUserIdActivateActivateUser(
        {
          ...options,
          ...localOptions,
          throwOnError: true,
        }
      );
      return data;
    },
  };
  return mutationOptions;
};

export const adminPostApiV1AdminUsersUserIdDeactivateDeactivateUserQueryKey = (
  options: Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserData>
) =>
  createQueryKey(
    "adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser",
    options
  );

/**
 * Deactivate User
 * ‚ùå Deactivate User Account
 *
 * Suspend user account and revoke API access.
 * Temporary suspension without data loss.
 *
 * **Effects:**
 * - Blocks login attempts
 * - Revokes API access tokens
 * - Suspends DPI service usage
 * - Maintains audit trail
 *
 * **Use Cases:**
 * - Policy violation suspension
 * - Security incident response
 * - Temporary account freeze
 *
 * **Reversible:** Account can be reactivated
 */
export const adminPostApiV1AdminUsersUserIdDeactivateDeactivateUserOptions = (
  options: Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } =
        await adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser({
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        });
      return data;
    },
    queryKey:
      adminPostApiV1AdminUsersUserIdDeactivateDeactivateUserQueryKey(options),
  });
};

/**
 * Deactivate User
 * ‚ùå Deactivate User Account
 *
 * Suspend user account and revoke API access.
 * Temporary suspension without data loss.
 *
 * **Effects:**
 * - Blocks login attempts
 * - Revokes API access tokens
 * - Suspends DPI service usage
 * - Maintains audit trail
 *
 * **Use Cases:**
 * - Policy violation suspension
 * - Security incident response
 * - Temporary account freeze
 *
 * **Reversible:** Account can be reactivated
 */
export const adminPostApiV1AdminUsersUserIdDeactivateDeactivateUserMutation = (
  options?: Partial<
    Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserData>
  >
): UseMutationOptions<
  unknown,
  AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserError,
  Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserError,
    Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUserData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } =
        await adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser({
          ...options,
          ...localOptions,
          throwOnError: true,
        });
      return data;
    },
  };
  return mutationOptions;
};

export const adminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordQueryKey =
  (
    options: Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordData>
  ) =>
    createQueryKey(
      "adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword",
      options
    );

/**
 * Reset User Password
 * üîë Admin Password Reset
 *
 * Reset user password for account recovery.
 * Sends secure notification to user email.
 *
 * **Request Body:**
 * ```json
 * {
 * "new_password": "NewSecurePass123"
 * }
 * ```
 *
 * **Security Process:**
 * 1. Validates admin permissions
 * 2. Hashes new password securely
 * 3. Updates user credentials
 * 4. Sends notification email
 * 5. Logs password change event
 *
 * **Best Practice:** User should change password on next login
 */
export const adminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordOptions =
  (
    options: Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordData>
  ) => {
    return queryOptions({
      queryFn: async ({ queryKey, signal }) => {
        const { data } =
          await adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true,
          });
        return data;
      },
      queryKey:
        adminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordQueryKey(
          options
        ),
    });
  };

/**
 * Reset User Password
 * üîë Admin Password Reset
 *
 * Reset user password for account recovery.
 * Sends secure notification to user email.
 *
 * **Request Body:**
 * ```json
 * {
 * "new_password": "NewSecurePass123"
 * }
 * ```
 *
 * **Security Process:**
 * 1. Validates admin permissions
 * 2. Hashes new password securely
 * 3. Updates user credentials
 * 4. Sends notification email
 * 5. Logs password change event
 *
 * **Best Practice:** User should change password on next login
 */
export const adminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordMutation =
  (
    options?: Partial<
      Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordData>
    >
  ): UseMutationOptions<
    unknown,
    AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordError,
    Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordData>
  > => {
    const mutationOptions: UseMutationOptions<
      unknown,
      AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordError,
      Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPasswordData>
    > = {
      mutationFn: async (localOptions) => {
        const { data } =
          await adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword({
            ...options,
            ...localOptions,
            throwOnError: true,
          });
        return data;
      },
    };
    return mutationOptions;
  };

export const smsPostApiV1SmsSendSendSingleSmsQueryKey = (
  options: Options<SmsPostApiV1SmsSendSendSingleSmsData>
) => createQueryKey("smsPostApiV1SmsSendSendSingleSms", options);

/**
 * Send Single Sms
 */
export const smsPostApiV1SmsSendSendSingleSmsOptions = (
  options: Options<SmsPostApiV1SmsSendSendSingleSmsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await smsPostApiV1SmsSendSendSingleSms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: smsPostApiV1SmsSendSendSingleSmsQueryKey(options),
  });
};

/**
 * Send Single Sms
 */
export const smsPostApiV1SmsSendSendSingleSmsMutation = (
  options?: Partial<Options<SmsPostApiV1SmsSendSendSingleSmsData>>
): UseMutationOptions<
  unknown,
  SmsPostApiV1SmsSendSendSingleSmsError,
  Options<SmsPostApiV1SmsSendSendSingleSmsData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    SmsPostApiV1SmsSendSendSingleSmsError,
    Options<SmsPostApiV1SmsSendSendSingleSmsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await smsPostApiV1SmsSendSendSingleSms({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const smsPostApiV1SmsSendBulkSendBulkSmsQueryKey = (
  options: Options<SmsPostApiV1SmsSendBulkSendBulkSmsData>
) => createQueryKey("smsPostApiV1SmsSendBulkSendBulkSms", options);

/**
 * Send Bulk Sms
 */
export const smsPostApiV1SmsSendBulkSendBulkSmsOptions = (
  options: Options<SmsPostApiV1SmsSendBulkSendBulkSmsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await smsPostApiV1SmsSendBulkSendBulkSms({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: smsPostApiV1SmsSendBulkSendBulkSmsQueryKey(options),
  });
};

/**
 * Send Bulk Sms
 */
export const smsPostApiV1SmsSendBulkSendBulkSmsMutation = (
  options?: Partial<Options<SmsPostApiV1SmsSendBulkSendBulkSmsData>>
): UseMutationOptions<
  unknown,
  SmsPostApiV1SmsSendBulkSendBulkSmsError,
  Options<SmsPostApiV1SmsSendBulkSendBulkSmsData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    SmsPostApiV1SmsSendBulkSendBulkSmsError,
    Options<SmsPostApiV1SmsSendBulkSendBulkSmsData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await smsPostApiV1SmsSendBulkSendBulkSms({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const applicationGetApiV1SmsBalanceCheckBalanceQueryKey = (
  options?: Options<ApplicationGetApiV1SmsBalanceCheckBalanceData>
) => createQueryKey("applicationGetApiV1SmsBalanceCheckBalance", options);

/**
 * Check Balance
 */
export const applicationGetApiV1SmsBalanceCheckBalanceOptions = (
  options?: Options<ApplicationGetApiV1SmsBalanceCheckBalanceData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await applicationGetApiV1SmsBalanceCheckBalance({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: applicationGetApiV1SmsBalanceCheckBalanceQueryKey(options),
  });
};

export const webhookPostApiV1DeliveryReportHandleDeliveryReportQueryKey = (
  options?: Options<WebhookPostApiV1DeliveryReportHandleDeliveryReportData>
) =>
  createQueryKey("webhookPostApiV1DeliveryReportHandleDeliveryReport", options);

/**
 * Handle Delivery Report
 */
export const webhookPostApiV1DeliveryReportHandleDeliveryReportOptions = (
  options?: Options<WebhookPostApiV1DeliveryReportHandleDeliveryReportData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await webhookPostApiV1DeliveryReportHandleDeliveryReport(
        {
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        }
      );
      return data;
    },
    queryKey:
      webhookPostApiV1DeliveryReportHandleDeliveryReportQueryKey(options),
  });
};

/**
 * Handle Delivery Report
 */
export const webhookPostApiV1DeliveryReportHandleDeliveryReportMutation = (
  options?: Partial<
    Options<WebhookPostApiV1DeliveryReportHandleDeliveryReportData>
  >
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<WebhookPostApiV1DeliveryReportHandleDeliveryReportData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<WebhookPostApiV1DeliveryReportHandleDeliveryReportData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await webhookPostApiV1DeliveryReportHandleDeliveryReport(
        {
          ...options,
          ...localOptions,
          throwOnError: true,
        }
      );
      return data;
    },
  };
  return mutationOptions;
};

export const smsGetApiV1SmsStatusMessageIdGetMessageStatusQueryKey = (
  options: Options<SmsGetApiV1SmsStatusMessageIdGetMessageStatusData>
) => createQueryKey("smsGetApiV1SmsStatusMessageIdGetMessageStatus", options);

/**
 * Get Message Status
 */
export const smsGetApiV1SmsStatusMessageIdGetMessageStatusOptions = (
  options: Options<SmsGetApiV1SmsStatusMessageIdGetMessageStatusData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await smsGetApiV1SmsStatusMessageIdGetMessageStatus({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: smsGetApiV1SmsStatusMessageIdGetMessageStatusQueryKey(options),
  });
};

export const apiGetRootRoot2QueryKey = (
  options?: Options<ApiGetRootRoot2Data>
) => createQueryKey("apiGetRootRoot2", options);

/**
 * Root
 */
export const apiGetRootRoot2Options = (
  options?: Options<ApiGetRootRoot2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetRootRoot2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetRootRoot2QueryKey(options),
  });
};

export const readyReadyGetQueryKey = (options?: Options<ReadyReadyGetData>) =>
  createQueryKey("readyReadyGet", options);

/**
 * Ready
 */
export const readyReadyGetOptions = (options?: Options<ReadyReadyGetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await readyReadyGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: readyReadyGetQueryKey(options),
  });
};

export const getModelsApiV1ModelsGroqGetQueryKey = (
  options?: Options<GetModelsApiV1ModelsGroqGetData>
) => createQueryKey("getModelsApiV1ModelsGroqGet", options);

/**
 * Retrieve available AI models
 * This endpoint returns a list of all available AI models that can be used for generating responses.
 *
 * **Behavior**:
 * - Fetches all currently supported models from the Groq AI platform.
 * - Returns the models as a simple list of strings (model names or IDs).
 * - No authentication is required for anonymous access (optional to add auth later).
 *
 * **Response**:
 * - `200 OK`: A JSON list of model names/IDs, for example:
 * ```json
 * [
 * {
 * "id": "meta-llama/llama-4-maverick-17b-128e-instruct",
 * "owned_by": "Meta",
 * "active": true,
 * "context_window": 131072,
 * "max_completion_tokens": 8192
 * }
 * ]
 * ```
 *
 * **Notes**:
 * - This list is dynamic and may change as new models are added or deprecated.
 * - Clients can use these model IDs when making requests to the `/chat/` endpoint.
 */
export const getModelsApiV1ModelsGroqGetOptions = (
  options?: Options<GetModelsApiV1ModelsGroqGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getModelsApiV1ModelsGroqGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getModelsApiV1ModelsGroqGetQueryKey(options),
  });
};

export const getOpenaiModelsApiV1ModelsOpenaiGetQueryKey = (
  options?: Options<GetOpenaiModelsApiV1ModelsOpenaiGetData>
) => createQueryKey("getOpenaiModelsApiV1ModelsOpenaiGet", options);

/**
 * Retrieve available OpenAI models
 * This endpoint returns a list of all available OpenAI models that can be used for generating responses.
 *
 * **Behavior**:
 * - Fetches all currently supported models from the OpenAI platform.
 * - Returns the models as a simple list of strings (model names or IDs).
 * - No authentication is required for anonymous access (optional to add auth later).
 *
 * **Response**:
 * - `200 OK`: A JSON list of model names/IDs, for example:
 * ```json
 * [
 * {
 * "id": "gpt-4",
 * "owned_by": "openai",
 * "active": true,
 * "context_window": 8192,
 * "max_completion_tokens": 4096
 * }
 * ]
 * ```
 *
 * **Notes**:
 * - This list is dynamic and may change as new models are added or deprecated.
 * - Clients can use these model IDs when making requests to the `/chat/` endpoint.
 */
export const getOpenaiModelsApiV1ModelsOpenaiGetOptions = (
  options?: Options<GetOpenaiModelsApiV1ModelsOpenaiGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOpenaiModelsApiV1ModelsOpenaiGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOpenaiModelsApiV1ModelsOpenaiGetQueryKey(options),
  });
};

export const chatApiV1ChatPostQueryKey = (
  options: Options<ChatApiV1ChatPostData>
) => createQueryKey("chatApiV1ChatPost", options);

/**
 * Send a message to the AI and receive a response
 * This endpoint allows the user to send a message to the AI model and receive a response.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Behavior**:
 * - If `session_id` is provided, the message will be added to that session.
 * - If `session_id` is not provided, a new session will be created automatically.
 * - The AI response is generated using the specified model and parameters.
 *
 * **Request Body Parameters**:
 * - `model_id` (optional, string): The AI model to use for generating responses. Defaults to the platform default if not provided.
 * - `session_id` (optional, string): Existing chat session ID. Leave empty to start a new session.
 * - `user_input` (required, string): The message text you want the AI to respond to.
 * - `is_openai` (optional, boolean): Set `True` to use OpenAI API; `False` to use internal AI model. Defaults to `False`.
 * - `temperature` (optional, float): Controls randomness of AI responses (0 = deterministic, 1 = creative). Default is 0.0.
 * - `max_tokens` (optional, int): Maximum tokens allowed in AI response. Defaults to 2000.
 * - `system_prompt` (optional, string): Custom system prompt to guide AI behavior.
 *
 * **Response**:
 * - `chat_messages` (list of messages): Contains both user and AI messages with timestamps and token usage.
 * - `session_id` (string): The session ID for the conversation.
 * - `is_openai` (boolean): Indicates which AI engine generated the response.
 * - `session_total_tokens` (int): The accumulated tokens used in this session.
 */
export const chatApiV1ChatPostOptions = (
  options: Options<ChatApiV1ChatPostData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await chatApiV1ChatPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: chatApiV1ChatPostQueryKey(options),
  });
};

/**
 * Send a message to the AI and receive a response
 * This endpoint allows the user to send a message to the AI model and receive a response.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Behavior**:
 * - If `session_id` is provided, the message will be added to that session.
 * - If `session_id` is not provided, a new session will be created automatically.
 * - The AI response is generated using the specified model and parameters.
 *
 * **Request Body Parameters**:
 * - `model_id` (optional, string): The AI model to use for generating responses. Defaults to the platform default if not provided.
 * - `session_id` (optional, string): Existing chat session ID. Leave empty to start a new session.
 * - `user_input` (required, string): The message text you want the AI to respond to.
 * - `is_openai` (optional, boolean): Set `True` to use OpenAI API; `False` to use internal AI model. Defaults to `False`.
 * - `temperature` (optional, float): Controls randomness of AI responses (0 = deterministic, 1 = creative). Default is 0.0.
 * - `max_tokens` (optional, int): Maximum tokens allowed in AI response. Defaults to 2000.
 * - `system_prompt` (optional, string): Custom system prompt to guide AI behavior.
 *
 * **Response**:
 * - `chat_messages` (list of messages): Contains both user and AI messages with timestamps and token usage.
 * - `session_id` (string): The session ID for the conversation.
 * - `is_openai` (boolean): Indicates which AI engine generated the response.
 * - `session_total_tokens` (int): The accumulated tokens used in this session.
 */
export const chatApiV1ChatPostMutation = (
  options?: Partial<Options<ChatApiV1ChatPostData>>
): UseMutationOptions<
  ChatApiV1ChatPostResponse,
  ChatApiV1ChatPostError,
  Options<ChatApiV1ChatPostData>
> => {
  const mutationOptions: UseMutationOptions<
    ChatApiV1ChatPostResponse,
    ChatApiV1ChatPostError,
    Options<ChatApiV1ChatPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await chatApiV1ChatPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getChatHistoryApiV1ChatSessionIdSessionGetQueryKey = (
  options: Options<GetChatHistoryApiV1ChatSessionIdSessionGetData>
) => createQueryKey("getChatHistoryApiV1ChatSessionIdSessionGet", options);

/**
 * Retrieve the chat history for a session
 * Fetches all messages for a specific chat session.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Path Parameters**:
 * - `session_id` (string, required): The ID of the session whose messages you want to retrieve.
 *
 * **Response**:
 * - `chat_messages` (list of messages): Messages in chronological order.
 * - `session_id` (string): The session ID.
 * - `is_openai` (boolean): Always `False` for retrieved messages.
 * - `session_total_tokens` (int): The accumulated tokens used in this session.
 *
 * **Errors**:
 * - `404 Not Found`: If the session does not exist.
 * - `500 Internal Server Error`: If there is a server/database error.
 */
export const getChatHistoryApiV1ChatSessionIdSessionGetOptions = (
  options: Options<GetChatHistoryApiV1ChatSessionIdSessionGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getChatHistoryApiV1ChatSessionIdSessionGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getChatHistoryApiV1ChatSessionIdSessionGetQueryKey(options),
  });
};

export const getChatSessionsApiV1ChatSessionsAllGetQueryKey = (
  options?: Options<GetChatSessionsApiV1ChatSessionsAllGetData>
) => createQueryKey("getChatSessionsApiV1ChatSessionsAllGet", options);

/**
 * Get all chat sessions
 * Returns a list of all chat sessions for the authenticated user.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Response**:
 * - List of `ChatSession` objects, each containing session metadata and associated messages.
 */
export const getChatSessionsApiV1ChatSessionsAllGetOptions = (
  options?: Options<GetChatSessionsApiV1ChatSessionsAllGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getChatSessionsApiV1ChatSessionsAllGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getChatSessionsApiV1ChatSessionsAllGetQueryKey(options),
  });
};

export const queryRagApiV1RagQueryPostQueryKey = (
  options: Options<QueryRagApiV1RagQueryPostData>
) => createQueryKey("queryRagApiV1RagQueryPost", options);

/**
 * Query the RAG (Retrieval-Augmented Generation) system
 * This endpoint allows users to query the RAG system, which combines a vector database
 * with a language model to generate answers based on uploaded documents.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `user_request.query` (str): The text query you want the system to answer.
 * - `user_request.model_id` (Optional[str]): The ID of the LLM model to use. If not provided, the default model is used.
 * - `user_request.system_prompt` (Optional[str]): Optional custom system prompt to influence the answer.
 *
 * **Behavior:**
 * - Uses the embedding model stored in the application state to retrieve relevant documents.
 * - Passes the retrieved context along with the query to the specified LLM.
 * - Returns the generated answer.
 *
 * **Response:**
 * ```json
 * {
 * "answer": "The system-generated answer based on your query and documents."
 * }
 * ```
 */
export const queryRagApiV1RagQueryPostOptions = (
  options: Options<QueryRagApiV1RagQueryPostData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await queryRagApiV1RagQueryPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: queryRagApiV1RagQueryPostQueryKey(options),
  });
};

/**
 * Query the RAG (Retrieval-Augmented Generation) system
 * This endpoint allows users to query the RAG system, which combines a vector database
 * with a language model to generate answers based on uploaded documents.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `user_request.query` (str): The text query you want the system to answer.
 * - `user_request.model_id` (Optional[str]): The ID of the LLM model to use. If not provided, the default model is used.
 * - `user_request.system_prompt` (Optional[str]): Optional custom system prompt to influence the answer.
 *
 * **Behavior:**
 * - Uses the embedding model stored in the application state to retrieve relevant documents.
 * - Passes the retrieved context along with the query to the specified LLM.
 * - Returns the generated answer.
 *
 * **Response:**
 * ```json
 * {
 * "answer": "The system-generated answer based on your query and documents."
 * }
 * ```
 */
export const queryRagApiV1RagQueryPostMutation = (
  options?: Partial<Options<QueryRagApiV1RagQueryPostData>>
): UseMutationOptions<
  QueryRagApiV1RagQueryPostResponse,
  QueryRagApiV1RagQueryPostError,
  Options<QueryRagApiV1RagQueryPostData>
> => {
  const mutationOptions: UseMutationOptions<
    QueryRagApiV1RagQueryPostResponse,
    QueryRagApiV1RagQueryPostError,
    Options<QueryRagApiV1RagQueryPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await queryRagApiV1RagQueryPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadForRagApiV1RagUploadPostQueryKey = (
  options: Options<UploadForRagApiV1RagUploadPostData>
) => createQueryKey("uploadForRagApiV1RagUploadPost", options);

/**
 * Upload documents for RAG system
 * This endpoint allows users to upload documents (PDFs, text files, etc.)
 * that will be processed and embedded for retrieval by the RAG system.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `files` (List[UploadFile]): A list of files to upload. Multiple files can be uploaded at once.
 *
 * **Behavior:**
 * - Embeds the uploaded documents using the system's embedding model.
 * - Stores them in the vector database for later retrieval.
 * - Each document is associated with the user ID (currently using 'anonymous').
 *
 * **Response:**
 * ```json
 * {
 * "status": "success",
 * "uploaded_files": ["file1.pdf", "file2.txt"]
 * }
 * ```
 */
export const uploadForRagApiV1RagUploadPostOptions = (
  options: Options<UploadForRagApiV1RagUploadPostData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadForRagApiV1RagUploadPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadForRagApiV1RagUploadPostQueryKey(options),
  });
};

/**
 * Upload documents for RAG system
 * This endpoint allows users to upload documents (PDFs, text files, etc.)
 * that will be processed and embedded for retrieval by the RAG system.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `files` (List[UploadFile]): A list of files to upload. Multiple files can be uploaded at once.
 *
 * **Behavior:**
 * - Embeds the uploaded documents using the system's embedding model.
 * - Stores them in the vector database for later retrieval.
 * - Each document is associated with the user ID (currently using 'anonymous').
 *
 * **Response:**
 * ```json
 * {
 * "status": "success",
 * "uploaded_files": ["file1.pdf", "file2.txt"]
 * }
 * ```
 */
export const uploadForRagApiV1RagUploadPostMutation = (
  options?: Partial<Options<UploadForRagApiV1RagUploadPostData>>
): UseMutationOptions<
  UploadForRagApiV1RagUploadPostResponse,
  UploadForRagApiV1RagUploadPostError,
  Options<UploadForRagApiV1RagUploadPostData>
> => {
  const mutationOptions: UseMutationOptions<
    UploadForRagApiV1RagUploadPostResponse,
    UploadForRagApiV1RagUploadPostError,
    Options<UploadForRagApiV1RagUploadPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await uploadForRagApiV1RagUploadPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const speechToTextApiV1SpitchSpeechToTextPostQueryKey = (
  options: Options<SpeechToTextApiV1SpitchSpeechToTextPostData>
) => createQueryKey("speechToTextApiV1SpitchSpeechToTextPost", options);

/**
 * Transcribe audio to text
 * Convert an audio file into written text.
 *
 * **Parameters:**
 * - `file` (UploadFile): The audio file to transcribe. Supported formats include mp3, wav, etc.
 * - `language` (str, optional): Language code of the audio. Defaults to 'en' (English).
 * - `model` (str, optional): The transcription model to use. Defaults to 'mansa_v1'.
 *
 * **Returns:**
 * - `text` (str): The transcribed text from the audio.
 */
export const speechToTextApiV1SpitchSpeechToTextPostOptions = (
  options: Options<SpeechToTextApiV1SpitchSpeechToTextPostData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await speechToTextApiV1SpitchSpeechToTextPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: speechToTextApiV1SpitchSpeechToTextPostQueryKey(options),
  });
};

/**
 * Transcribe audio to text
 * Convert an audio file into written text.
 *
 * **Parameters:**
 * - `file` (UploadFile): The audio file to transcribe. Supported formats include mp3, wav, etc.
 * - `language` (str, optional): Language code of the audio. Defaults to 'en' (English).
 * - `model` (str, optional): The transcription model to use. Defaults to 'mansa_v1'.
 *
 * **Returns:**
 * - `text` (str): The transcribed text from the audio.
 */
export const speechToTextApiV1SpitchSpeechToTextPostMutation = (
  options?: Partial<Options<SpeechToTextApiV1SpitchSpeechToTextPostData>>
): UseMutationOptions<
  unknown,
  SpeechToTextApiV1SpitchSpeechToTextPostError,
  Options<SpeechToTextApiV1SpitchSpeechToTextPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    SpeechToTextApiV1SpitchSpeechToTextPostError,
    Options<SpeechToTextApiV1SpitchSpeechToTextPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await speechToTextApiV1SpitchSpeechToTextPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const textToSpeechApiV1SpitchTextToSpeechPostQueryKey = (
  options: Options<TextToSpeechApiV1SpitchTextToSpeechPostData>
) => createQueryKey("textToSpeechApiV1SpitchTextToSpeechPost", options);

/**
 * Generate speech from text
 * Convert input text into spoken audio (speech).
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `text` (str): The text content to convert to speech.
 * - `language` (str, optional): Language code for speech generation. Defaults to 'en'.
 * - `voice` (str, optional): The voice to use for speech. Defaults to 'lina'.
 *
 * **Returns:**
 * - An audio file (MP3) containing the spoken text.
 */
export const textToSpeechApiV1SpitchTextToSpeechPostOptions = (
  options: Options<TextToSpeechApiV1SpitchTextToSpeechPostData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await textToSpeechApiV1SpitchTextToSpeechPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: textToSpeechApiV1SpitchTextToSpeechPostQueryKey(options),
  });
};

/**
 * Generate speech from text
 * Convert input text into spoken audio (speech).
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `text` (str): The text content to convert to speech.
 * - `language` (str, optional): Language code for speech generation. Defaults to 'en'.
 * - `voice` (str, optional): The voice to use for speech. Defaults to 'lina'.
 *
 * **Returns:**
 * - An audio file (MP3) containing the spoken text.
 */
export const textToSpeechApiV1SpitchTextToSpeechPostMutation = (
  options?: Partial<Options<TextToSpeechApiV1SpitchTextToSpeechPostData>>
): UseMutationOptions<
  unknown,
  TextToSpeechApiV1SpitchTextToSpeechPostError,
  Options<TextToSpeechApiV1SpitchTextToSpeechPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    TextToSpeechApiV1SpitchTextToSpeechPostError,
    Options<TextToSpeechApiV1SpitchTextToSpeechPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await textToSpeechApiV1SpitchTextToSpeechPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const translateApiV1SpitchTranslatePostQueryKey = (
  options: Options<TranslateApiV1SpitchTranslatePostData>
) => createQueryKey("translateApiV1SpitchTranslatePost", options);

/**
 * Translate text between languages
 * Translate input text from a source language to a target language.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `text` (str): The text content to translate.
 * - `source` (str, optional): Source language code. Defaults to 'en' (English).
 * - `target` (str, optional): Target language code. Defaults to 'yo' (Yoruba).
 *
 * **Returns:**
 * - `translation` (str): The translated text.
 */
export const translateApiV1SpitchTranslatePostOptions = (
  options: Options<TranslateApiV1SpitchTranslatePostData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await translateApiV1SpitchTranslatePost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: translateApiV1SpitchTranslatePostQueryKey(options),
  });
};

/**
 * Translate text between languages
 * Translate input text from a source language to a target language.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `text` (str): The text content to translate.
 * - `source` (str, optional): Source language code. Defaults to 'en' (English).
 * - `target` (str, optional): Target language code. Defaults to 'yo' (Yoruba).
 *
 * **Returns:**
 * - `translation` (str): The translated text.
 */
export const translateApiV1SpitchTranslatePostMutation = (
  options?: Partial<Options<TranslateApiV1SpitchTranslatePostData>>
): UseMutationOptions<
  unknown,
  TranslateApiV1SpitchTranslatePostError,
  Options<TranslateApiV1SpitchTranslatePostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    TranslateApiV1SpitchTranslatePostError,
    Options<TranslateApiV1SpitchTranslatePostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await translateApiV1SpitchTranslatePost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rootGetQueryKey = (options?: Options<RootGetData>) =>
  createQueryKey("rootGet", options);

/**
 * Root
 */
export const rootGetOptions = (options?: Options<RootGetData>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rootGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rootGetQueryKey(options),
  });
};

export const dpiApiPostApiV1NinLookupNinLookupQueryKey = (
  options: Options<DpiApiPostApiV1NinLookupNinLookupData>
) => createQueryKey("dpiApiPostApiV1NinLookupNinLookup", options);

/**
 * NIN Verification
 * Verify a Nigerian National Identification Number (NIN) and retrieve associated identity information
 */
export const dpiApiPostApiV1NinLookupNinLookupOptions = (
  options: Options<DpiApiPostApiV1NinLookupNinLookupData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await dpiApiPostApiV1NinLookupNinLookup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: dpiApiPostApiV1NinLookupNinLookupQueryKey(options),
  });
};

/**
 * NIN Verification
 * Verify a Nigerian National Identification Number (NIN) and retrieve associated identity information
 */
export const dpiApiPostApiV1NinLookupNinLookupMutation = (
  options?: Partial<Options<DpiApiPostApiV1NinLookupNinLookupData>>
): UseMutationOptions<
  DpiApiPostApiV1NinLookupNinLookupResponse,
  DpiApiPostApiV1NinLookupNinLookupError,
  Options<DpiApiPostApiV1NinLookupNinLookupData>
> => {
  const mutationOptions: UseMutationOptions<
    DpiApiPostApiV1NinLookupNinLookupResponse,
    DpiApiPostApiV1NinLookupNinLookupError,
    Options<DpiApiPostApiV1NinLookupNinLookupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await dpiApiPostApiV1NinLookupNinLookup({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const dpiApiPostApiV1BvnLookupBvnLookupQueryKey = (
  options: Options<DpiApiPostApiV1BvnLookupBvnLookupData>
) => createQueryKey("dpiApiPostApiV1BvnLookupBvnLookup", options);

/**
 * BVN Verification
 * Verify a Bank Verification Number (BVN) and retrieve associated identity information
 */
export const dpiApiPostApiV1BvnLookupBvnLookupOptions = (
  options: Options<DpiApiPostApiV1BvnLookupBvnLookupData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await dpiApiPostApiV1BvnLookupBvnLookup({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: dpiApiPostApiV1BvnLookupBvnLookupQueryKey(options),
  });
};

/**
 * BVN Verification
 * Verify a Bank Verification Number (BVN) and retrieve associated identity information
 */
export const dpiApiPostApiV1BvnLookupBvnLookupMutation = (
  options?: Partial<Options<DpiApiPostApiV1BvnLookupBvnLookupData>>
): UseMutationOptions<
  DpiApiPostApiV1BvnLookupBvnLookupResponse,
  DpiApiPostApiV1BvnLookupBvnLookupError,
  Options<DpiApiPostApiV1BvnLookupBvnLookupData>
> => {
  const mutationOptions: UseMutationOptions<
    DpiApiPostApiV1BvnLookupBvnLookupResponse,
    DpiApiPostApiV1BvnLookupBvnLookupError,
    Options<DpiApiPostApiV1BvnLookupBvnLookupData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await dpiApiPostApiV1BvnLookupBvnLookup({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const dpiApiPostApiV1CreditScoreCreditScoreQueryKey = (
  options: Options<DpiApiPostApiV1CreditScoreCreditScoreData>
) => createQueryKey("dpiApiPostApiV1CreditScoreCreditScore", options);

/**
 * Credit Score Lookup
 * Retrieve credit score information using Bank Verification Number (BVN)
 */
export const dpiApiPostApiV1CreditScoreCreditScoreOptions = (
  options: Options<DpiApiPostApiV1CreditScoreCreditScoreData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await dpiApiPostApiV1CreditScoreCreditScore({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: dpiApiPostApiV1CreditScoreCreditScoreQueryKey(options),
  });
};

/**
 * Credit Score Lookup
 * Retrieve credit score information using Bank Verification Number (BVN)
 */
export const dpiApiPostApiV1CreditScoreCreditScoreMutation = (
  options?: Partial<Options<DpiApiPostApiV1CreditScoreCreditScoreData>>
): UseMutationOptions<
  DpiApiPostApiV1CreditScoreCreditScoreResponse,
  DpiApiPostApiV1CreditScoreCreditScoreError,
  Options<DpiApiPostApiV1CreditScoreCreditScoreData>
> => {
  const mutationOptions: UseMutationOptions<
    DpiApiPostApiV1CreditScoreCreditScoreResponse,
    DpiApiPostApiV1CreditScoreCreditScoreError,
    Options<DpiApiPostApiV1CreditScoreCreditScoreData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await dpiApiPostApiV1CreditScoreCreditScore({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const dpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinQueryKey =
  (
    options: Options<DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinData>
  ) =>
    createQueryKey(
      "dpiApiPostApiV1SelfieVerificationNinSelfieVerificationNin",
      options
    );

/**
 * Selfie + NIN Verification
 * Verify identity by matching a selfie image with NIN records using facial recognition
 */
export const dpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinOptions =
  (
    options: Options<DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinData>
  ) => {
    return queryOptions({
      queryFn: async ({ queryKey, signal }) => {
        const { data } =
          await dpiApiPostApiV1SelfieVerificationNinSelfieVerificationNin({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true,
          });
        return data;
      },
      queryKey:
        dpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinQueryKey(
          options
        ),
    });
  };

/**
 * Selfie + NIN Verification
 * Verify identity by matching a selfie image with NIN records using facial recognition
 */
export const dpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinMutation =
  (
    options?: Partial<
      Options<DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinData>
    >
  ): UseMutationOptions<
    DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinResponse,
    DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinError,
    Options<DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinData>
  > => {
    const mutationOptions: UseMutationOptions<
      DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinResponse,
      DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinError,
      Options<DpiApiPostApiV1SelfieVerificationNinSelfieVerificationNinData>
    > = {
      mutationFn: async (localOptions) => {
        const { data } =
          await dpiApiPostApiV1SelfieVerificationNinSelfieVerificationNin({
            ...options,
            ...localOptions,
            throwOnError: true,
          });
        return data;
      },
    };
    return mutationOptions;
  };

export const apiGetRootRoot3QueryKey = (
  options?: Options<ApiGetRootRoot3Data>
) => createQueryKey("apiGetRootRoot3", options);

/**
 * Root
 */
export const apiGetRootRoot3Options = (
  options?: Options<ApiGetRootRoot3Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetRootRoot3({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetRootRoot3QueryKey(options),
  });
};

export const getNearbyPlacesApiV1MapsNearbyGetQueryKey = (
  options: Options<GetNearbyPlacesApiV1MapsNearbyGetData>
) => createQueryKey("getNearbyPlacesApiV1MapsNearbyGet", options);

/**
 * Get Nearby Places
 * Search for nearby places around a given location. Returns distance in meters.
 *
 * Args:
 * lat (float): Latitude of the location.
 * lng (float): Longitude of the location.
 * keyword (str, optional): Search keyword (e.g., "hospital", "pharmacy").
 * Default is "hospital".
 * radius_m (int, optional): Search radius in meters. Default is 2000.
 *
 * Returns:
 * list: Places with details from Google Maps, including a direct Maps URL.
 */
export const getNearbyPlacesApiV1MapsNearbyGetOptions = (
  options: Options<GetNearbyPlacesApiV1MapsNearbyGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getNearbyPlacesApiV1MapsNearbyGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getNearbyPlacesApiV1MapsNearbyGetQueryKey(options),
  });
};

export const getDistanceApiV1MapsDistanceGetQueryKey = (
  options: Options<GetDistanceApiV1MapsDistanceGetData>
) => createQueryKey("getDistanceApiV1MapsDistanceGet", options);

/**
 * Get Distance
 * Get travel distance and duration between two locations. Returns distance in meters and duration in seconds.
 *
 * Args:
 * origin (str): Starting point (address or "lat,lng").
 * destination (str): End point (address or "lat,lng").
 * mode (str, optional): Travel mode ("driving", "walking", "bicycling", "transit").
 * Default is "driving".
 *
 * Returns:
 * dict: Distance matrix response with distance and duration details.
 */
export const getDistanceApiV1MapsDistanceGetOptions = (
  options: Options<GetDistanceApiV1MapsDistanceGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDistanceApiV1MapsDistanceGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDistanceApiV1MapsDistanceGetQueryKey(options),
  });
};

export const getDirectionsApiV1MapsDirectionsGetQueryKey = (
  options: Options<GetDirectionsApiV1MapsDirectionsGetData>
) => createQueryKey("getDirectionsApiV1MapsDirectionsGet", options);

/**
 * Get Directions
 * Get directions between two locations. Returned distance in meters and duration in seconds.
 *
 * Args:
 * origin (str): Starting point (address or "lat,lng").
 * destination (str): End point (address or "lat,lng").
 * mode (str, optional): Travel mode ("driving", "walking", "bicycling", "transit").
 * Default is "driving".
 *
 * Returns:
 * list: Routes with legs, steps, distance, duration, and polyline.
 */
export const getDirectionsApiV1MapsDirectionsGetOptions = (
  options: Options<GetDirectionsApiV1MapsDirectionsGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDirectionsApiV1MapsDirectionsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDirectionsApiV1MapsDirectionsGetQueryKey(options),
  });
};

export const getStaticMapApiV1MapsStaticGetQueryKey = (
  options: Options<GetStaticMapApiV1MapsStaticGetData>
) => createQueryKey("getStaticMapApiV1MapsStaticGet", options);

/**
 * Get Static Map
 * Generate and stream a Google Static Map image with optional markers and path.
 * The API key is not exposed to the client.
 *
 * Args:
 * center (str): Map center (e.g., "New York,NY" or "lat,lng").
 * markers (list[str], optional): Marker coordinates/labels.
 * Example: `&markers=color:blue|label:S|37.421655,-122.085637`
 * path (list[str], optional): Coordinates for a polyline path.
 * Example: `&path=color:0xff0000ff|weight:5|37.421655,-122.085637|37.420999,-122.086894`
 * zoom (int, optional): Zoom level (default 14).
 *
 * Returns:
 * StreamingResponse: The map image as a PNG stream.
 */
export const getStaticMapApiV1MapsStaticGetOptions = (
  options: Options<GetStaticMapApiV1MapsStaticGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStaticMapApiV1MapsStaticGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStaticMapApiV1MapsStaticGetQueryKey(options),
  });
};

export const getRouteApiV1MapsRoutesPostQueryKey = (
  options: Options<GetRouteApiV1MapsRoutesPostData>
) => createQueryKey("getRouteApiV1MapsRoutesPost", options);

/**
 * Get Route
 * Compute a driving route between an origin and a destination.
 *
 * Args:
 * request (RouteRequest): Request object containing origin, destination,
 * travel mode, routing preferences, and modifiers.
 *
 * Returns:
 * dict: Route details including duration, distance (meters), encoded polyline,
 * decoded coordinates (if polyline lib installed), and route legs.
 * Returns error info if the request fails or no route is found.
 */
export const getRouteApiV1MapsRoutesPostOptions = (
  options: Options<GetRouteApiV1MapsRoutesPostData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRouteApiV1MapsRoutesPost({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRouteApiV1MapsRoutesPostQueryKey(options),
  });
};

/**
 * Get Route
 * Compute a driving route between an origin and a destination.
 *
 * Args:
 * request (RouteRequest): Request object containing origin, destination,
 * travel mode, routing preferences, and modifiers.
 *
 * Returns:
 * dict: Route details including duration, distance (meters), encoded polyline,
 * decoded coordinates (if polyline lib installed), and route legs.
 * Returns error info if the request fails or no route is found.
 */
export const getRouteApiV1MapsRoutesPostMutation = (
  options?: Partial<Options<GetRouteApiV1MapsRoutesPostData>>
): UseMutationOptions<
  unknown,
  GetRouteApiV1MapsRoutesPostError,
  Options<GetRouteApiV1MapsRoutesPostData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    GetRouteApiV1MapsRoutesPostError,
    Options<GetRouteApiV1MapsRoutesPostData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await getRouteApiV1MapsRoutesPost({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const apiGetRootRoot4QueryKey = (
  options?: Options<ApiGetRootRoot4Data>
) => createQueryKey("apiGetRootRoot4", options);

/**
 * Root
 */
export const apiGetRootRoot4Options = (
  options?: Options<ApiGetRootRoot4Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetRootRoot4({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetRootRoot4QueryKey(options),
  });
};

export const apiPostUssdUssdProxyQueryKey = (
  options?: Options<ApiPostUssdUssdProxyData>
) => createQueryKey("apiPostUssdUssdProxy", options);

/**
 * Ussd Proxy
 * This is the USSD gateway proxy endpoint. It receives the request from Africa's Talking
 * and forwards it to the correct client's callback URL based on the serviceCode.
 */
export const apiPostUssdUssdProxyOptions = (
  options?: Options<ApiPostUssdUssdProxyData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiPostUssdUssdProxy({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiPostUssdUssdProxyQueryKey(options),
  });
};

/**
 * Ussd Proxy
 * This is the USSD gateway proxy endpoint. It receives the request from Africa's Talking
 * and forwards it to the correct client's callback URL based on the serviceCode.
 */
export const apiPostUssdUssdProxyMutation = (
  options?: Partial<Options<ApiPostUssdUssdProxyData>>
): UseMutationOptions<
  unknown,
  ApiPostUssdUssdProxyError,
  Options<ApiPostUssdUssdProxyData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ApiPostUssdUssdProxyError,
    Options<ApiPostUssdUssdProxyData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await apiPostUssdUssdProxy({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const apiPostUssdNotificationUssdNotificationQueryKey = (
  options?: Options<ApiPostUssdNotificationUssdNotificationData>
) => createQueryKey("apiPostUssdNotificationUssdNotification", options);

/**
 * Ussd Notification
 * Handles end-of-session USSD notifications.
 * This endpoint is for receiving the final summary of a session.
 */
export const apiPostUssdNotificationUssdNotificationOptions = (
  options?: Options<ApiPostUssdNotificationUssdNotificationData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiPostUssdNotificationUssdNotification({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiPostUssdNotificationUssdNotificationQueryKey(options),
  });
};

/**
 * Ussd Notification
 * Handles end-of-session USSD notifications.
 * This endpoint is for receiving the final summary of a session.
 */
export const apiPostUssdNotificationUssdNotificationMutation = (
  options?: Partial<Options<ApiPostUssdNotificationUssdNotificationData>>
): UseMutationOptions<
  unknown,
  ApiPostUssdNotificationUssdNotificationError,
  Options<ApiPostUssdNotificationUssdNotificationData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ApiPostUssdNotificationUssdNotificationError,
    Options<ApiPostUssdNotificationUssdNotificationData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await apiPostUssdNotificationUssdNotification({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV18MedicalUssdCallback8MedicalQueryKey = (
  options?: Options<UssdPostApiV18MedicalUssdCallback8MedicalData>
) => createQueryKey("ussdPostApiV18MedicalUssdCallback8Medical", options);

/**
 * Callback 8Medical
 * This endpoint simulates 8Medical_USSD's application server without signature verification.
 */
export const ussdPostApiV18MedicalUssdCallback8MedicalOptions = (
  options?: Options<UssdPostApiV18MedicalUssdCallback8MedicalData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV18MedicalUssdCallback8Medical({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV18MedicalUssdCallback8MedicalQueryKey(options),
  });
};

/**
 * Callback 8Medical
 * This endpoint simulates 8Medical_USSD's application server without signature verification.
 */
export const ussdPostApiV18MedicalUssdCallback8MedicalMutation = (
  options?: Partial<Options<UssdPostApiV18MedicalUssdCallback8MedicalData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV18MedicalUssdCallback8MedicalData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV18MedicalUssdCallback8MedicalData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV18MedicalUssdCallback8Medical({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1AlajoUssdCallbackAlajoQueryKey = (
  options?: Options<UssdPostApiV1AlajoUssdCallbackAlajoData>
) => createQueryKey("ussdPostApiV1AlajoUssdCallbackAlajo", options);

/**
 * Callback Alajo
 * This endpoint simulates Alajo_USSD's application server without signature verification.
 */
export const ussdPostApiV1AlajoUssdCallbackAlajoOptions = (
  options?: Options<UssdPostApiV1AlajoUssdCallbackAlajoData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1AlajoUssdCallbackAlajo({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1AlajoUssdCallbackAlajoQueryKey(options),
  });
};

/**
 * Callback Alajo
 * This endpoint simulates Alajo_USSD's application server without signature verification.
 */
export const ussdPostApiV1AlajoUssdCallbackAlajoMutation = (
  options?: Partial<Options<UssdPostApiV1AlajoUssdCallbackAlajoData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1AlajoUssdCallbackAlajoData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1AlajoUssdCallbackAlajoData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1AlajoUssdCallbackAlajo({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1ClafiyaUssdCallbackClafiyaQueryKey = (
  options?: Options<UssdPostApiV1ClafiyaUssdCallbackClafiyaData>
) => createQueryKey("ussdPostApiV1ClafiyaUssdCallbackClafiya", options);

/**
 * Callback Clafiya
 * This endpoint simulates Clafiya_USSD's application server without signature verification.
 */
export const ussdPostApiV1ClafiyaUssdCallbackClafiyaOptions = (
  options?: Options<UssdPostApiV1ClafiyaUssdCallbackClafiyaData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1ClafiyaUssdCallbackClafiya({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1ClafiyaUssdCallbackClafiyaQueryKey(options),
  });
};

/**
 * Callback Clafiya
 * This endpoint simulates Clafiya_USSD's application server without signature verification.
 */
export const ussdPostApiV1ClafiyaUssdCallbackClafiyaMutation = (
  options?: Partial<Options<UssdPostApiV1ClafiyaUssdCallbackClafiyaData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1ClafiyaUssdCallbackClafiyaData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1ClafiyaUssdCallbackClafiyaData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1ClafiyaUssdCallbackClafiya({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1EvetUssdCallbackEvetQueryKey = (
  options?: Options<UssdPostApiV1EvetUssdCallbackEvetData>
) => createQueryKey("ussdPostApiV1EvetUssdCallbackEvet", options);

/**
 * Callback Evet
 * This endpoint simulates Evet_USSD's application server without signature verification.
 */
export const ussdPostApiV1EvetUssdCallbackEvetOptions = (
  options?: Options<UssdPostApiV1EvetUssdCallbackEvetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1EvetUssdCallbackEvet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1EvetUssdCallbackEvetQueryKey(options),
  });
};

/**
 * Callback Evet
 * This endpoint simulates Evet_USSD's application server without signature verification.
 */
export const ussdPostApiV1EvetUssdCallbackEvetMutation = (
  options?: Partial<Options<UssdPostApiV1EvetUssdCallbackEvetData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1EvetUssdCallbackEvetData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1EvetUssdCallbackEvetData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1EvetUssdCallbackEvet({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1FertitudeUssdCallbackFertitudeQueryKey = (
  options?: Options<UssdPostApiV1FertitudeUssdCallbackFertitudeData>
) => createQueryKey("ussdPostApiV1FertitudeUssdCallbackFertitude", options);

/**
 * Callback Fertitude
 * This endpoint simulates Fertitude_USSD's application server without signature verification.
 */
export const ussdPostApiV1FertitudeUssdCallbackFertitudeOptions = (
  options?: Options<UssdPostApiV1FertitudeUssdCallbackFertitudeData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1FertitudeUssdCallbackFertitude({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1FertitudeUssdCallbackFertitudeQueryKey(options),
  });
};

/**
 * Callback Fertitude
 * This endpoint simulates Fertitude_USSD's application server without signature verification.
 */
export const ussdPostApiV1FertitudeUssdCallbackFertitudeMutation = (
  options?: Partial<Options<UssdPostApiV1FertitudeUssdCallbackFertitudeData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1FertitudeUssdCallbackFertitudeData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1FertitudeUssdCallbackFertitudeData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1FertitudeUssdCallbackFertitude({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1FologUssdCallbackFologQueryKey = (
  options?: Options<UssdPostApiV1FologUssdCallbackFologData>
) => createQueryKey("ussdPostApiV1FologUssdCallbackFolog", options);

/**
 * Callback Folog
 * This endpoint simulates Folog_USSD's application server without signature verification.
 */
export const ussdPostApiV1FologUssdCallbackFologOptions = (
  options?: Options<UssdPostApiV1FologUssdCallbackFologData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1FologUssdCallbackFolog({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1FologUssdCallbackFologQueryKey(options),
  });
};

/**
 * Callback Folog
 * This endpoint simulates Folog_USSD's application server without signature verification.
 */
export const ussdPostApiV1FologUssdCallbackFologMutation = (
  options?: Partial<Options<UssdPostApiV1FologUssdCallbackFologData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1FologUssdCallbackFologData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1FologUssdCallbackFologData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1FologUssdCallbackFolog({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1MylturaUssdCallbackMylturaQueryKey = (
  options?: Options<UssdPostApiV1MylturaUssdCallbackMylturaData>
) => createQueryKey("ussdPostApiV1MylturaUssdCallbackMyltura", options);

/**
 * Callback Myltura
 * This endpoint simulates Myltura_USSD's application server without signature verification.
 */
export const ussdPostApiV1MylturaUssdCallbackMylturaOptions = (
  options?: Options<UssdPostApiV1MylturaUssdCallbackMylturaData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1MylturaUssdCallbackMyltura({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1MylturaUssdCallbackMylturaQueryKey(options),
  });
};

/**
 * Callback Myltura
 * This endpoint simulates Myltura_USSD's application server without signature verification.
 */
export const ussdPostApiV1MylturaUssdCallbackMylturaMutation = (
  options?: Partial<Options<UssdPostApiV1MylturaUssdCallbackMylturaData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1MylturaUssdCallbackMylturaData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1MylturaUssdCallbackMylturaData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1MylturaUssdCallbackMyltura({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1UhcTechUssdCallbackUhcTechQueryKey = (
  options?: Options<UssdPostApiV1UhcTechUssdCallbackUhcTechData>
) => createQueryKey("ussdPostApiV1UhcTechUssdCallbackUhcTech", options);

/**
 * Callback Uhc Tech
 * This endpoint simulates UHC_Tech_USSD's application server without signature verification.
 */
export const ussdPostApiV1UhcTechUssdCallbackUhcTechOptions = (
  options?: Options<UssdPostApiV1UhcTechUssdCallbackUhcTechData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1UhcTechUssdCallbackUhcTech({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1UhcTechUssdCallbackUhcTechQueryKey(options),
  });
};

/**
 * Callback Uhc Tech
 * This endpoint simulates UHC_Tech_USSD's application server without signature verification.
 */
export const ussdPostApiV1UhcTechUssdCallbackUhcTechMutation = (
  options?: Partial<Options<UssdPostApiV1UhcTechUssdCallbackUhcTechData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1UhcTechUssdCallbackUhcTechData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1UhcTechUssdCallbackUhcTechData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1UhcTechUssdCallbackUhcTech({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1XboxUssdCallbackXboxQueryKey = (
  options?: Options<UssdPostApiV1XboxUssdCallbackXboxData>
) => createQueryKey("ussdPostApiV1XboxUssdCallbackXbox", options);

/**
 * Callback Xbox
 * This endpoint simulates XBOX_USSD's application server without signature verification.
 */
export const ussdPostApiV1XboxUssdCallbackXboxOptions = (
  options?: Options<UssdPostApiV1XboxUssdCallbackXboxData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1XboxUssdCallbackXbox({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1XboxUssdCallbackXboxQueryKey(options),
  });
};

/**
 * Callback Xbox
 * This endpoint simulates XBOX_USSD's application server without signature verification.
 */
export const ussdPostApiV1XboxUssdCallbackXboxMutation = (
  options?: Partial<Options<UssdPostApiV1XboxUssdCallbackXboxData>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1XboxUssdCallbackXboxData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1XboxUssdCallbackXboxData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1XboxUssdCallbackXbox({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestFertitudeUssdTestFertitudeUssdQueryKey = (
  options: Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssdData>
) => createQueryKey("ussdPostApiV1TestFertitudeUssdTestFertitudeUssd", options);

/**
 * Test Fertitude Ussd
 * Test endpoint for Fertitude USSD logic.
 * Accepts POST form data and returns the same response as /fertitude_ussd.
 *
 *
 * Requires:
 *
 * sessionId e.g., lirwf23455
 *
 * phoneNumber e.g., +2348103317200
 *
 * text (location of interest in the pipeline) e.g., "" (empty for first interaction), "1", "1*1", etc. like you would interact with USSD codes
 */
export const ussdPostApiV1TestFertitudeUssdTestFertitudeUssdOptions = (
  options: Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestFertitudeUssdTestFertitudeUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestFertitudeUssdTestFertitudeUssdQueryKey(options),
  });
};

/**
 * Test Fertitude Ussd
 * Test endpoint for Fertitude USSD logic.
 * Accepts POST form data and returns the same response as /fertitude_ussd.
 *
 *
 * Requires:
 *
 * sessionId e.g., lirwf23455
 *
 * phoneNumber e.g., +2348103317200
 *
 * text (location of interest in the pipeline) e.g., "" (empty for first interaction), "1", "1*1", etc. like you would interact with USSD codes
 */
export const ussdPostApiV1TestFertitudeUssdTestFertitudeUssdMutation = (
  options?: Partial<
    Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssdData>
  >
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestFertitudeUssdTestFertitudeUssdError,
  Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestFertitudeUssdTestFertitudeUssdError,
    Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestFertitudeUssdTestFertitudeUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1Test8MedicalUssdTest8MedicalUssdQueryKey = (
  options: Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssdData>
) => createQueryKey("ussdPostApiV1Test8MedicalUssdTest8MedicalUssd", options);

/**
 * Test 8Medical Ussd
 * Test endpoint for 8Medical_USSD logic.
 */
export const ussdPostApiV1Test8MedicalUssdTest8MedicalUssdOptions = (
  options: Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1Test8MedicalUssdTest8MedicalUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1Test8MedicalUssdTest8MedicalUssdQueryKey(options),
  });
};

/**
 * Test 8Medical Ussd
 * Test endpoint for 8Medical_USSD logic.
 */
export const ussdPostApiV1Test8MedicalUssdTest8MedicalUssdMutation = (
  options?: Partial<Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssdData>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1Test8MedicalUssdTest8MedicalUssdError,
  Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1Test8MedicalUssdTest8MedicalUssdError,
    Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1Test8MedicalUssdTest8MedicalUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestAlajoUssdTestAlajoUssdQueryKey = (
  options: Options<UssdPostApiV1TestAlajoUssdTestAlajoUssdData>
) => createQueryKey("ussdPostApiV1TestAlajoUssdTestAlajoUssd", options);

/**
 * Test Alajo Ussd
 * Test endpoint for Alajo_USSD logic.
 */
export const ussdPostApiV1TestAlajoUssdTestAlajoUssdOptions = (
  options: Options<UssdPostApiV1TestAlajoUssdTestAlajoUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestAlajoUssdTestAlajoUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestAlajoUssdTestAlajoUssdQueryKey(options),
  });
};

/**
 * Test Alajo Ussd
 * Test endpoint for Alajo_USSD logic.
 */
export const ussdPostApiV1TestAlajoUssdTestAlajoUssdMutation = (
  options?: Partial<Options<UssdPostApiV1TestAlajoUssdTestAlajoUssdData>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestAlajoUssdTestAlajoUssdError,
  Options<UssdPostApiV1TestAlajoUssdTestAlajoUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestAlajoUssdTestAlajoUssdError,
    Options<UssdPostApiV1TestAlajoUssdTestAlajoUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestAlajoUssdTestAlajoUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestClafiyaUssdTestClafiyaUssdQueryKey = (
  options: Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssdData>
) => createQueryKey("ussdPostApiV1TestClafiyaUssdTestClafiyaUssd", options);

/**
 * Test Clafiya Ussd
 * Test endpoint for Clafiya_USSD logic.
 */
export const ussdPostApiV1TestClafiyaUssdTestClafiyaUssdOptions = (
  options: Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestClafiyaUssdTestClafiyaUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestClafiyaUssdTestClafiyaUssdQueryKey(options),
  });
};

/**
 * Test Clafiya Ussd
 * Test endpoint for Clafiya_USSD logic.
 */
export const ussdPostApiV1TestClafiyaUssdTestClafiyaUssdMutation = (
  options?: Partial<Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssdData>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestClafiyaUssdTestClafiyaUssdError,
  Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestClafiyaUssdTestClafiyaUssdError,
    Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestClafiyaUssdTestClafiyaUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestEvetUssdTestEvetUssdQueryKey = (
  options: Options<UssdPostApiV1TestEvetUssdTestEvetUssdData>
) => createQueryKey("ussdPostApiV1TestEvetUssdTestEvetUssd", options);

/**
 * Test Evet Ussd
 * Test endpoint for Evet_USSD logic.
 */
export const ussdPostApiV1TestEvetUssdTestEvetUssdOptions = (
  options: Options<UssdPostApiV1TestEvetUssdTestEvetUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestEvetUssdTestEvetUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestEvetUssdTestEvetUssdQueryKey(options),
  });
};

/**
 * Test Evet Ussd
 * Test endpoint for Evet_USSD logic.
 */
export const ussdPostApiV1TestEvetUssdTestEvetUssdMutation = (
  options?: Partial<Options<UssdPostApiV1TestEvetUssdTestEvetUssdData>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestEvetUssdTestEvetUssdError,
  Options<UssdPostApiV1TestEvetUssdTestEvetUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestEvetUssdTestEvetUssdError,
    Options<UssdPostApiV1TestEvetUssdTestEvetUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestEvetUssdTestEvetUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestFologUssdTestFologUssdQueryKey = (
  options: Options<UssdPostApiV1TestFologUssdTestFologUssdData>
) => createQueryKey("ussdPostApiV1TestFologUssdTestFologUssd", options);

/**
 * Test Folog Ussd
 * Test endpoint for Folog_USSD logic.
 */
export const ussdPostApiV1TestFologUssdTestFologUssdOptions = (
  options: Options<UssdPostApiV1TestFologUssdTestFologUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestFologUssdTestFologUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestFologUssdTestFologUssdQueryKey(options),
  });
};

/**
 * Test Folog Ussd
 * Test endpoint for Folog_USSD logic.
 */
export const ussdPostApiV1TestFologUssdTestFologUssdMutation = (
  options?: Partial<Options<UssdPostApiV1TestFologUssdTestFologUssdData>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestFologUssdTestFologUssdError,
  Options<UssdPostApiV1TestFologUssdTestFologUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestFologUssdTestFologUssdError,
    Options<UssdPostApiV1TestFologUssdTestFologUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestFologUssdTestFologUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestMylturaUssdTestMylturaUssdQueryKey = (
  options: Options<UssdPostApiV1TestMylturaUssdTestMylturaUssdData>
) => createQueryKey("ussdPostApiV1TestMylturaUssdTestMylturaUssd", options);

/**
 * Test Myltura Ussd
 * Test endpoint for Myltura_USSD logic.
 */
export const ussdPostApiV1TestMylturaUssdTestMylturaUssdOptions = (
  options: Options<UssdPostApiV1TestMylturaUssdTestMylturaUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestMylturaUssdTestMylturaUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestMylturaUssdTestMylturaUssdQueryKey(options),
  });
};

/**
 * Test Myltura Ussd
 * Test endpoint for Myltura_USSD logic.
 */
export const ussdPostApiV1TestMylturaUssdTestMylturaUssdMutation = (
  options?: Partial<Options<UssdPostApiV1TestMylturaUssdTestMylturaUssdData>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestMylturaUssdTestMylturaUssdError,
  Options<UssdPostApiV1TestMylturaUssdTestMylturaUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestMylturaUssdTestMylturaUssdError,
    Options<UssdPostApiV1TestMylturaUssdTestMylturaUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestMylturaUssdTestMylturaUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestUhcTechUssdTestUhcTechUssdQueryKey = (
  options: Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssdData>
) => createQueryKey("ussdPostApiV1TestUhcTechUssdTestUhcTechUssd", options);

/**
 * Test Uhc Tech Ussd
 * Test endpoint for UHC_Tech_USSD logic.
 */
export const ussdPostApiV1TestUhcTechUssdTestUhcTechUssdOptions = (
  options: Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestUhcTechUssdTestUhcTechUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestUhcTechUssdTestUhcTechUssdQueryKey(options),
  });
};

/**
 * Test Uhc Tech Ussd
 * Test endpoint for UHC_Tech_USSD logic.
 */
export const ussdPostApiV1TestUhcTechUssdTestUhcTechUssdMutation = (
  options?: Partial<Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssdData>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestUhcTechUssdTestUhcTechUssdError,
  Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestUhcTechUssdTestUhcTechUssdError,
    Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestUhcTechUssdTestUhcTechUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestXboxUssdTestXboxUssdQueryKey = (
  options: Options<UssdPostApiV1TestXboxUssdTestXboxUssdData>
) => createQueryKey("ussdPostApiV1TestXboxUssdTestXboxUssd", options);

/**
 * Test Xbox Ussd
 * Test endpoint for XBOX_USSD logic.
 */
export const ussdPostApiV1TestXboxUssdTestXboxUssdOptions = (
  options: Options<UssdPostApiV1TestXboxUssdTestXboxUssdData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestXboxUssdTestXboxUssd({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestXboxUssdTestXboxUssdQueryKey(options),
  });
};

/**
 * Test Xbox Ussd
 * Test endpoint for XBOX_USSD logic.
 */
export const ussdPostApiV1TestXboxUssdTestXboxUssdMutation = (
  options?: Partial<Options<UssdPostApiV1TestXboxUssdTestXboxUssdData>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestXboxUssdTestXboxUssdError,
  Options<UssdPostApiV1TestXboxUssdTestXboxUssdData>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestXboxUssdTestXboxUssdError,
    Options<UssdPostApiV1TestXboxUssdTestXboxUssdData>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestXboxUssdTestXboxUssd({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const apiGetMetricsMetricsQueryKey = (
  options?: Options<ApiGetMetricsMetricsData>
) => createQueryKey("apiGetMetricsMetrics", options);

/**
 * Metrics
 * Endpoint that serves Prometheus metrics.
 */
export const apiGetMetricsMetricsOptions = (
  options?: Options<ApiGetMetricsMetricsData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetMetricsMetrics({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetMetricsMetricsQueryKey(options),
  });
};

export const apiGetHealthHealthCheckQueryKey = (
  options?: Options<ApiGetHealthHealthCheckData>
) => createQueryKey("apiGetHealthHealthCheck", options);

/**
 * Health Check
 * Health check endpoint.
 */
export const apiGetHealthHealthCheckOptions = (
  options?: Options<ApiGetHealthHealthCheckData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetHealthHealthCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetHealthHealthCheckQueryKey(options),
  });
};

export const apiGetRootRoot5QueryKey = (
  options?: Options<ApiGetRootRoot5Data>
) => createQueryKey("apiGetRootRoot5", options);

/**
 * Root
 * Root endpoint.
 */
export const apiGetRootRoot5Options = (
  options?: Options<ApiGetRootRoot5Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetRootRoot5({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetRootRoot5QueryKey(options),
  });
};

export const authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2QueryKey =
  (
    options?: Options<AuthenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2Data>
  ) =>
    createQueryKey(
      "authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2",
      options
    );

/**
 * Openid Configuration
 * üîç OpenID Connect Configuration
 *
 * Standard OpenID Connect discovery endpoint providing
 * metadata about the authorization server.
 *
 * **Returns:**
 * - Issuer information
 * - Supported endpoints
 * - Token types and algorithms
 * - Grant types supported
 *
 * **Compliance:**
 * - OpenID Connect Discovery 1.0
 * - OAuth 2.0 Authorization Server Metadata
 */
export const authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2Options =
  (
    options?: Options<AuthenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2Data>
  ) => {
    return queryOptions({
      queryFn: async ({ queryKey, signal }) => {
        const { data } =
          await authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2(
            {
              ...options,
              ...queryKey[0],
              signal,
              throwOnError: true,
            }
          );
        return data;
      },
      queryKey:
        authenticationGetApiV1AuthWellKnownOpenidConfigurationOpenidConfiguration2QueryKey(
          options
        ),
    });
  };

export const authenticationGetApiV1AuthWellKnownJwksJsonJwks2QueryKey = (
  options?: Options<AuthenticationGetApiV1AuthWellKnownJwksJsonJwks2Data>
) =>
  createQueryKey("authenticationGetApiV1AuthWellKnownJwksJsonJwks2", options);

/**
 * Jwks
 * üîë JSON Web Key Set
 *
 * Provides public keys for JWT token verification.
 * Used by clients to validate JWT signatures.
 *
 * **Returns:**
 * - JSON Web Key Set (JWKS)
 * - Public key information
 * - Key usage and algorithms
 *
 * **Note:** Currently using HMAC (symmetric key)
 * For production, consider RSA/ECDSA asymmetric keys
 */
export const authenticationGetApiV1AuthWellKnownJwksJsonJwks2Options = (
  options?: Options<AuthenticationGetApiV1AuthWellKnownJwksJsonJwks2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationGetApiV1AuthWellKnownJwksJsonJwks2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticationGetApiV1AuthWellKnownJwksJsonJwks2QueryKey(options),
  });
};

export const authenticationPostApiV1AuthLoginLoginUser2QueryKey = (
  options: Options<AuthenticationPostApiV1AuthLoginLoginUser2Data>
) => createQueryKey("authenticationPostApiV1AuthLoginLoginUser2", options);

/**
 * Login User
 * üîê OAuth2 Compatible Login
 *
 * Authenticate user with form data and return JWT tokens.
 * Compatible with OAuth2 password flow for API clients.
 *
 * **Request Format:**
 * - Content-Type: application/x-www-form-urlencoded
 * - username: Email or username
 * - password: User password
 *
 * **Response:**
 * - access_token: JWT token for API access
 * - refresh_token: Token for refreshing access
 * - token_type: "bearer"
 * - expires_in: Token expiration in seconds
 *
 * **Use Cases:**
 * - OAuth2 client applications
 * - API integrations requiring form-based auth
 * - Third-party service authentication
 */
export const authenticationPostApiV1AuthLoginLoginUser2Options = (
  options: Options<AuthenticationPostApiV1AuthLoginLoginUser2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationPostApiV1AuthLoginLoginUser2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticationPostApiV1AuthLoginLoginUser2QueryKey(options),
  });
};

/**
 * Login User
 * üîê OAuth2 Compatible Login
 *
 * Authenticate user with form data and return JWT tokens.
 * Compatible with OAuth2 password flow for API clients.
 *
 * **Request Format:**
 * - Content-Type: application/x-www-form-urlencoded
 * - username: Email or username
 * - password: User password
 *
 * **Response:**
 * - access_token: JWT token for API access
 * - refresh_token: Token for refreshing access
 * - token_type: "bearer"
 * - expires_in: Token expiration in seconds
 *
 * **Use Cases:**
 * - OAuth2 client applications
 * - API integrations requiring form-based auth
 * - Third-party service authentication
 */
export const authenticationPostApiV1AuthLoginLoginUser2Mutation = (
  options?: Partial<Options<AuthenticationPostApiV1AuthLoginLoginUser2Data>>
): UseMutationOptions<
  AuthenticationPostApiV1AuthLoginLoginUser2Response,
  AuthenticationPostApiV1AuthLoginLoginUser2Error,
  Options<AuthenticationPostApiV1AuthLoginLoginUser2Data>
> => {
  const mutationOptions: UseMutationOptions<
    AuthenticationPostApiV1AuthLoginLoginUser2Response,
    AuthenticationPostApiV1AuthLoginLoginUser2Error,
    Options<AuthenticationPostApiV1AuthLoginLoginUser2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authenticationPostApiV1AuthLoginLoginUser2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const authenticationPostApiV1AuthLoginJsonLoginUserJson2QueryKey = (
  options: Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Data>
) =>
  createQueryKey("authenticationPostApiV1AuthLoginJsonLoginUserJson2", options);

/**
 * Login User Json
 * üöÄ JSON Login for Nigerian Startups
 *
 * Primary login endpoint for Nigerian DPI developers.
 * Accepts JSON payload with email or username authentication.
 *
 * **Request Example:**
 * ```json
 * {
 * "identifier": "adebayo@fintech.ng",  // Email or username
 * "password": "SecurePass123"
 * }
 * ```
 *
 * **Features:**
 * - ‚úÖ Email or username login
 * - ‚úÖ JWT token generation
 * - ‚úÖ Last login tracking
 * - ‚úÖ Request correlation ID support
 *
 * **Nigerian Context:**
 * - Supports Nigerian email domains (.ng, .com.ng)
 * - Optimized for fintech and DPI applications
 * - Audit logging for regulatory compliance
 */
export const authenticationPostApiV1AuthLoginJsonLoginUserJson2Options = (
  options: Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationPostApiV1AuthLoginJsonLoginUserJson2(
        {
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        }
      );
      return data;
    },
    queryKey:
      authenticationPostApiV1AuthLoginJsonLoginUserJson2QueryKey(options),
  });
};

/**
 * Login User Json
 * üöÄ JSON Login for Nigerian Startups
 *
 * Primary login endpoint for Nigerian DPI developers.
 * Accepts JSON payload with email or username authentication.
 *
 * **Request Example:**
 * ```json
 * {
 * "identifier": "adebayo@fintech.ng",  // Email or username
 * "password": "SecurePass123"
 * }
 * ```
 *
 * **Features:**
 * - ‚úÖ Email or username login
 * - ‚úÖ JWT token generation
 * - ‚úÖ Last login tracking
 * - ‚úÖ Request correlation ID support
 *
 * **Nigerian Context:**
 * - Supports Nigerian email domains (.ng, .com.ng)
 * - Optimized for fintech and DPI applications
 * - Audit logging for regulatory compliance
 */
export const authenticationPostApiV1AuthLoginJsonLoginUserJson2Mutation = (
  options?: Partial<
    Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Data>
  >
): UseMutationOptions<
  AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Response,
  AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Error,
  Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Data>
> => {
  const mutationOptions: UseMutationOptions<
    AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Response,
    AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Error,
    Options<AuthenticationPostApiV1AuthLoginJsonLoginUserJson2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authenticationPostApiV1AuthLoginJsonLoginUserJson2(
        {
          ...options,
          ...localOptions,
          throwOnError: true,
        }
      );
      return data;
    },
  };
  return mutationOptions;
};

export const authenticationGetApiV1AuthMeReadUserMe2QueryKey = (
  options?: Options<AuthenticationGetApiV1AuthMeReadUserMe2Data>
) => createQueryKey("authenticationGetApiV1AuthMeReadUserMe2", options);

/**
 * Read User Me
 * üë§ Get Current User Profile
 *
 * Retrieve authenticated user's profile information.
 * Requires valid JWT token in Authorization header.
 *
 * **Headers Required:**
 * - Authorization: Bearer {access_token}
 *
 * **Returns:**
 * - User profile with Nigerian DPI context
 * - NIN/BVN verification status
 * - Account activity information
 *
 * **Security:**
 * - Token validation required
 * - Active user status check
 * - Soft-delete filtering applied
 */
export const authenticationGetApiV1AuthMeReadUserMe2Options = (
  options?: Options<AuthenticationGetApiV1AuthMeReadUserMe2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationGetApiV1AuthMeReadUserMe2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticationGetApiV1AuthMeReadUserMe2QueryKey(options),
  });
};

export const authenticationPostApiV1AuthLogoutLogoutUser2QueryKey = (
  options?: Options<AuthenticationPostApiV1AuthLogoutLogoutUser2Data>
) => createQueryKey("authenticationPostApiV1AuthLogoutLogoutUser2", options);

/**
 * Logout User
 * üö™ User Logout
 *
 * Logout current user session.
 * Client should remove tokens from storage.
 *
 * **Process:**
 * 1. Client receives logout confirmation
 * 2. Client removes access/refresh tokens
 * 3. Tokens become invalid on next request
 *
 * **Best Practice:**
 * - Clear all stored authentication data
 * - Redirect to login page
 * - Invalidate any cached user data
 *
 * **Note:** Server-side token blacklisting available
 * for enhanced security in production.
 */
export const authenticationPostApiV1AuthLogoutLogoutUser2Options = (
  options?: Options<AuthenticationPostApiV1AuthLogoutLogoutUser2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await authenticationPostApiV1AuthLogoutLogoutUser2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: authenticationPostApiV1AuthLogoutLogoutUser2QueryKey(options),
  });
};

/**
 * Logout User
 * üö™ User Logout
 *
 * Logout current user session.
 * Client should remove tokens from storage.
 *
 * **Process:**
 * 1. Client receives logout confirmation
 * 2. Client removes access/refresh tokens
 * 3. Tokens become invalid on next request
 *
 * **Best Practice:**
 * - Clear all stored authentication data
 * - Redirect to login page
 * - Invalidate any cached user data
 *
 * **Note:** Server-side token blacklisting available
 * for enhanced security in production.
 */
export const authenticationPostApiV1AuthLogoutLogoutUser2Mutation = (
  options?: Partial<Options<AuthenticationPostApiV1AuthLogoutLogoutUser2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<AuthenticationPostApiV1AuthLogoutLogoutUser2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<AuthenticationPostApiV1AuthLogoutLogoutUser2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await authenticationPostApiV1AuthLogoutLogoutUser2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oauth2PostApiV1Oauth2ClientsCreateOauthClient2QueryKey = (
  options: Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Data>
) => createQueryKey("oauth2PostApiV1Oauth2ClientsCreateOauthClient2", options);

/**
 * Create Oauth Client
 * Create a new OAuth2 client.
 */
export const oauth2PostApiV1Oauth2ClientsCreateOauthClient2Options = (
  options: Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauth2PostApiV1Oauth2ClientsCreateOauthClient2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauth2PostApiV1Oauth2ClientsCreateOauthClient2QueryKey(options),
  });
};

/**
 * Create Oauth Client
 * Create a new OAuth2 client.
 */
export const oauth2PostApiV1Oauth2ClientsCreateOauthClient2Mutation = (
  options?: Partial<Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Data>>
): UseMutationOptions<
  Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Response,
  Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Error,
  Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Data>
> => {
  const mutationOptions: UseMutationOptions<
    Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Response,
    Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Error,
    Options<Oauth2PostApiV1Oauth2ClientsCreateOauthClient2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await oauth2PostApiV1Oauth2ClientsCreateOauthClient2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2QueryKey = (
  options: Options<Oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2Data>
) =>
  createQueryKey("oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2", options);

/**
 * Get Oauth Client
 * Get OAuth2 client by ID.
 */
export const oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2Options = (
  options: Options<Oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2(
        {
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        }
      );
      return data;
    },
    queryKey:
      oauth2GetApiV1Oauth2ClientsClientIdGetOauthClient2QueryKey(options),
  });
};

export const oauth2GetApiV1Oauth2AuthorizeAuthorize2QueryKey = (
  options: Options<Oauth2GetApiV1Oauth2AuthorizeAuthorize2Data>
) => createQueryKey("oauth2GetApiV1Oauth2AuthorizeAuthorize2", options);

/**
 * Authorize
 * OAuth2 authorization endpoint.
 */
export const oauth2GetApiV1Oauth2AuthorizeAuthorize2Options = (
  options: Options<Oauth2GetApiV1Oauth2AuthorizeAuthorize2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauth2GetApiV1Oauth2AuthorizeAuthorize2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauth2GetApiV1Oauth2AuthorizeAuthorize2QueryKey(options),
  });
};

export const oauth2PostApiV1Oauth2TokenGetToken2QueryKey = (
  options: Options<Oauth2PostApiV1Oauth2TokenGetToken2Data>
) => createQueryKey("oauth2PostApiV1Oauth2TokenGetToken2", options);

/**
 * Get Token
 * OAuth2 token endpoint.
 */
export const oauth2PostApiV1Oauth2TokenGetToken2Options = (
  options: Options<Oauth2PostApiV1Oauth2TokenGetToken2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await oauth2PostApiV1Oauth2TokenGetToken2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: oauth2PostApiV1Oauth2TokenGetToken2QueryKey(options),
  });
};

/**
 * Get Token
 * OAuth2 token endpoint.
 */
export const oauth2PostApiV1Oauth2TokenGetToken2Mutation = (
  options?: Partial<Options<Oauth2PostApiV1Oauth2TokenGetToken2Data>>
): UseMutationOptions<
  Oauth2PostApiV1Oauth2TokenGetToken2Response,
  Oauth2PostApiV1Oauth2TokenGetToken2Error,
  Options<Oauth2PostApiV1Oauth2TokenGetToken2Data>
> => {
  const mutationOptions: UseMutationOptions<
    Oauth2PostApiV1Oauth2TokenGetToken2Response,
    Oauth2PostApiV1Oauth2TokenGetToken2Error,
    Options<Oauth2PostApiV1Oauth2TokenGetToken2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await oauth2PostApiV1Oauth2TokenGetToken2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const adminGetApiV1AdminUsersListUsers2QueryKey = (
  options?: Options<AdminGetApiV1AdminUsersListUsers2Data>
) => createQueryKey("adminGetApiV1AdminUsersListUsers2", options);

/**
 * List Users
 * üìÑ List All Nigerian Startup Users
 *
 * Retrieve paginated list of all registered users.
 * Includes verification status and activity metrics.
 *
 * **Query Parameters:**
 * - skip: Number of records to skip (default: 0)
 * - limit: Maximum records to return (default: 100)
 *
 * **Response Includes:**
 * - User profiles with NIN/BVN status
 * - Last login and activity data
 * - Account verification levels
 * - Soft-delete filtering applied
 *
 * **Admin Only:** Platform oversight and user management
 */
export const adminGetApiV1AdminUsersListUsers2Options = (
  options?: Options<AdminGetApiV1AdminUsersListUsers2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await adminGetApiV1AdminUsersListUsers2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: adminGetApiV1AdminUsersListUsers2QueryKey(options),
  });
};

export const adminPostApiV1AdminUsersCreateUser2QueryKey = (
  options: Options<AdminPostApiV1AdminUsersCreateUser2Data>
) => createQueryKey("adminPostApiV1AdminUsersCreateUser2", options);

/**
 * Create User
 * üë• Create Nigerian Startup Account
 *
 * Create new user account for Nigerian DPI developers.
 * Only accessible by platform administrators.
 *
 * **Request Example:**
 * ```json
 * {
 * "email": "developer@fintech.ng",
 * "username": "fintech_dev",
 * "password": "TempPass123",
 * "first_name": "Adebayo",
 * "last_name": "Ogundimu",
 * "role": "developer"  // Optional: admin, developer
 * }
 * ```
 *
 * **Features:**
 * - ‚úÖ Email uniqueness validation
 * - ‚úÖ Username availability check
 * - ‚úÖ Automatic welcome email
 * - ‚úÖ Nigerian domain support (.ng, .com.ng)
 *
 * **Admin Access Required:**
 * - Must be authenticated as admin
 * - Closed sandbox: Only 9 Nigerian startups
 */
export const adminPostApiV1AdminUsersCreateUser2Options = (
  options: Options<AdminPostApiV1AdminUsersCreateUser2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await adminPostApiV1AdminUsersCreateUser2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: adminPostApiV1AdminUsersCreateUser2QueryKey(options),
  });
};

/**
 * Create User
 * üë• Create Nigerian Startup Account
 *
 * Create new user account for Nigerian DPI developers.
 * Only accessible by platform administrators.
 *
 * **Request Example:**
 * ```json
 * {
 * "email": "developer@fintech.ng",
 * "username": "fintech_dev",
 * "password": "TempPass123",
 * "first_name": "Adebayo",
 * "last_name": "Ogundimu",
 * "role": "developer"  // Optional: admin, developer
 * }
 * ```
 *
 * **Features:**
 * - ‚úÖ Email uniqueness validation
 * - ‚úÖ Username availability check
 * - ‚úÖ Automatic welcome email
 * - ‚úÖ Nigerian domain support (.ng, .com.ng)
 *
 * **Admin Access Required:**
 * - Must be authenticated as admin
 * - Closed sandbox: Only 9 Nigerian startups
 */
export const adminPostApiV1AdminUsersCreateUser2Mutation = (
  options?: Partial<Options<AdminPostApiV1AdminUsersCreateUser2Data>>
): UseMutationOptions<
  AdminPostApiV1AdminUsersCreateUser2Response,
  AdminPostApiV1AdminUsersCreateUser2Error,
  Options<AdminPostApiV1AdminUsersCreateUser2Data>
> => {
  const mutationOptions: UseMutationOptions<
    AdminPostApiV1AdminUsersCreateUser2Response,
    AdminPostApiV1AdminUsersCreateUser2Error,
    Options<AdminPostApiV1AdminUsersCreateUser2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await adminPostApiV1AdminUsersCreateUser2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

/**
 * Delete User
 * üóëÔ∏è Soft Delete User Account
 *
 * Mark user account as deleted (soft delete).
 * Preserves data for audit compliance.
 *
 * **Process:**
 * 1. Sets is_deleted = true
 * 2. Records deletion timestamp
 * 3. Maintains audit trail
 * 4. Frees email/username for reuse
 *
 * **Data Retention:**
 * - User data preserved for compliance
 * - API access immediately revoked
 * - Email/username become available
 *
 * **NDPR Compliant:** Nigerian Data Protection Regulation
 */
export const adminDeleteApiV1AdminUsersUserIdDeleteUser2Mutation = (
  options?: Partial<Options<AdminDeleteApiV1AdminUsersUserIdDeleteUser2Data>>
): UseMutationOptions<
  unknown,
  AdminDeleteApiV1AdminUsersUserIdDeleteUser2Error,
  Options<AdminDeleteApiV1AdminUsersUserIdDeleteUser2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AdminDeleteApiV1AdminUsersUserIdDeleteUser2Error,
    Options<AdminDeleteApiV1AdminUsersUserIdDeleteUser2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await adminDeleteApiV1AdminUsersUserIdDeleteUser2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const adminGetApiV1AdminUsersUserIdGetUser2QueryKey = (
  options: Options<AdminGetApiV1AdminUsersUserIdGetUser2Data>
) => createQueryKey("adminGetApiV1AdminUsersUserIdGetUser2", options);

/**
 * Get User
 * üîç Get Specific User Details
 *
 * Retrieve detailed information for a specific user.
 * Includes full profile and verification status.
 *
 * **Path Parameters:**
 * - user_id: Unique user identifier
 *
 * **Returns:**
 * - Complete user profile
 * - NIN/BVN verification status
 * - Account activity history
 * - Role and permissions
 *
 * **Use Cases:**
 * - User support and troubleshooting
 * - Account verification review
 * - Compliance auditing
 */
export const adminGetApiV1AdminUsersUserIdGetUser2Options = (
  options: Options<AdminGetApiV1AdminUsersUserIdGetUser2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await adminGetApiV1AdminUsersUserIdGetUser2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: adminGetApiV1AdminUsersUserIdGetUser2QueryKey(options),
  });
};

/**
 * Update User
 * ‚úèÔ∏è Update User Profile
 *
 * Modify user account information and settings.
 * Supports partial updates with validation.
 *
 * **Updatable Fields:**
 * - first_name, last_name
 * - email (with uniqueness check)
 * - username (with availability check)
 * - role (admin, developer)
 * - is_active status
 *
 * **Validation:**
 * - Email format and domain validation
 * - Username uniqueness across platform
 * - Role permission verification
 *
 * **Audit Trail:** All changes logged for compliance
 */
export const adminPutApiV1AdminUsersUserIdUpdateUser2Mutation = (
  options?: Partial<Options<AdminPutApiV1AdminUsersUserIdUpdateUser2Data>>
): UseMutationOptions<
  AdminPutApiV1AdminUsersUserIdUpdateUser2Response,
  AdminPutApiV1AdminUsersUserIdUpdateUser2Error,
  Options<AdminPutApiV1AdminUsersUserIdUpdateUser2Data>
> => {
  const mutationOptions: UseMutationOptions<
    AdminPutApiV1AdminUsersUserIdUpdateUser2Response,
    AdminPutApiV1AdminUsersUserIdUpdateUser2Error,
    Options<AdminPutApiV1AdminUsersUserIdUpdateUser2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await adminPutApiV1AdminUsersUserIdUpdateUser2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const adminPostApiV1AdminUsersUserIdActivateActivateUser2QueryKey = (
  options: Options<AdminPostApiV1AdminUsersUserIdActivateActivateUser2Data>
) =>
  createQueryKey(
    "adminPostApiV1AdminUsersUserIdActivateActivateUser2",
    options
  );

/**
 * Activate User
 * ‚úÖ Activate User Account
 *
 * Enable user account for API access.
 * Restores full platform functionality.
 *
 * **Effects:**
 * - Enables login and API access
 * - Restores DPI service usage
 * - Allows NIN/BVN verification
 * - Resumes audit logging
 *
 * **Use Cases:**
 * - New account activation
 * - Account restoration after suspension
 * - Startup onboarding completion
 *
 * **Notification:** User receives activation email
 */
export const adminPostApiV1AdminUsersUserIdActivateActivateUser2Options = (
  options: Options<AdminPostApiV1AdminUsersUserIdActivateActivateUser2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } =
        await adminPostApiV1AdminUsersUserIdActivateActivateUser2({
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        });
      return data;
    },
    queryKey:
      adminPostApiV1AdminUsersUserIdActivateActivateUser2QueryKey(options),
  });
};

/**
 * Activate User
 * ‚úÖ Activate User Account
 *
 * Enable user account for API access.
 * Restores full platform functionality.
 *
 * **Effects:**
 * - Enables login and API access
 * - Restores DPI service usage
 * - Allows NIN/BVN verification
 * - Resumes audit logging
 *
 * **Use Cases:**
 * - New account activation
 * - Account restoration after suspension
 * - Startup onboarding completion
 *
 * **Notification:** User receives activation email
 */
export const adminPostApiV1AdminUsersUserIdActivateActivateUser2Mutation = (
  options?: Partial<
    Options<AdminPostApiV1AdminUsersUserIdActivateActivateUser2Data>
  >
): UseMutationOptions<
  unknown,
  AdminPostApiV1AdminUsersUserIdActivateActivateUser2Error,
  Options<AdminPostApiV1AdminUsersUserIdActivateActivateUser2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AdminPostApiV1AdminUsersUserIdActivateActivateUser2Error,
    Options<AdminPostApiV1AdminUsersUserIdActivateActivateUser2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } =
        await adminPostApiV1AdminUsersUserIdActivateActivateUser2({
          ...options,
          ...localOptions,
          throwOnError: true,
        });
      return data;
    },
  };
  return mutationOptions;
};

export const adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2QueryKey = (
  options: Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Data>
) =>
  createQueryKey(
    "adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2",
    options
  );

/**
 * Deactivate User
 * ‚ùå Deactivate User Account
 *
 * Suspend user account and revoke API access.
 * Temporary suspension without data loss.
 *
 * **Effects:**
 * - Blocks login attempts
 * - Revokes API access tokens
 * - Suspends DPI service usage
 * - Maintains audit trail
 *
 * **Use Cases:**
 * - Policy violation suspension
 * - Security incident response
 * - Temporary account freeze
 *
 * **Reversible:** Account can be reactivated
 */
export const adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Options = (
  options: Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } =
        await adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2({
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        });
      return data;
    },
    queryKey:
      adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2QueryKey(options),
  });
};

/**
 * Deactivate User
 * ‚ùå Deactivate User Account
 *
 * Suspend user account and revoke API access.
 * Temporary suspension without data loss.
 *
 * **Effects:**
 * - Blocks login attempts
 * - Revokes API access tokens
 * - Suspends DPI service usage
 * - Maintains audit trail
 *
 * **Use Cases:**
 * - Policy violation suspension
 * - Security incident response
 * - Temporary account freeze
 *
 * **Reversible:** Account can be reactivated
 */
export const adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Mutation = (
  options?: Partial<
    Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Data>
  >
): UseMutationOptions<
  unknown,
  AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Error,
  Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Error,
    Options<AdminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } =
        await adminPostApiV1AdminUsersUserIdDeactivateDeactivateUser2({
          ...options,
          ...localOptions,
          throwOnError: true,
        });
      return data;
    },
  };
  return mutationOptions;
};

export const adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2QueryKey =
  (
    options: Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Data>
  ) =>
    createQueryKey(
      "adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2",
      options
    );

/**
 * Reset User Password
 * üîë Admin Password Reset
 *
 * Reset user password for account recovery.
 * Sends secure notification to user email.
 *
 * **Request Body:**
 * ```json
 * {
 * "new_password": "NewSecurePass123"
 * }
 * ```
 *
 * **Security Process:**
 * 1. Validates admin permissions
 * 2. Hashes new password securely
 * 3. Updates user credentials
 * 4. Sends notification email
 * 5. Logs password change event
 *
 * **Best Practice:** User should change password on next login
 */
export const adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Options =
  (
    options: Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Data>
  ) => {
    return queryOptions({
      queryFn: async ({ queryKey, signal }) => {
        const { data } =
          await adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true,
          });
        return data;
      },
      queryKey:
        adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2QueryKey(
          options
        ),
    });
  };

/**
 * Reset User Password
 * üîë Admin Password Reset
 *
 * Reset user password for account recovery.
 * Sends secure notification to user email.
 *
 * **Request Body:**
 * ```json
 * {
 * "new_password": "NewSecurePass123"
 * }
 * ```
 *
 * **Security Process:**
 * 1. Validates admin permissions
 * 2. Hashes new password securely
 * 3. Updates user credentials
 * 4. Sends notification email
 * 5. Logs password change event
 *
 * **Best Practice:** User should change password on next login
 */
export const adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Mutation =
  (
    options?: Partial<
      Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Data>
    >
  ): UseMutationOptions<
    unknown,
    AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Error,
    Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Data>
  > => {
    const mutationOptions: UseMutationOptions<
      unknown,
      AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Error,
      Options<AdminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2Data>
    > = {
      mutationFn: async (localOptions) => {
        const { data } =
          await adminPostApiV1AdminUsersUserIdResetPasswordResetUserPassword2({
            ...options,
            ...localOptions,
            throwOnError: true,
          });
        return data;
      },
    };
    return mutationOptions;
  };

export const healthGetApiV1HealthHealthCheckQueryKey = (
  options?: Options<HealthGetApiV1HealthHealthCheckData>
) => createQueryKey("healthGetApiV1HealthHealthCheck", options);

/**
 * Health Check
 */
export const healthGetApiV1HealthHealthCheckOptions = (
  options?: Options<HealthGetApiV1HealthHealthCheckData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthGetApiV1HealthHealthCheck({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthGetApiV1HealthHealthCheckQueryKey(options),
  });
};

export const smsPostApiV1SmsSendSendSingleSms2QueryKey = (
  options: Options<SmsPostApiV1SmsSendSendSingleSms2Data>
) => createQueryKey("smsPostApiV1SmsSendSendSingleSms2", options);

/**
 * Send Single Sms
 */
export const smsPostApiV1SmsSendSendSingleSms2Options = (
  options: Options<SmsPostApiV1SmsSendSendSingleSms2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await smsPostApiV1SmsSendSendSingleSms2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: smsPostApiV1SmsSendSendSingleSms2QueryKey(options),
  });
};

/**
 * Send Single Sms
 */
export const smsPostApiV1SmsSendSendSingleSms2Mutation = (
  options?: Partial<Options<SmsPostApiV1SmsSendSendSingleSms2Data>>
): UseMutationOptions<
  unknown,
  SmsPostApiV1SmsSendSendSingleSms2Error,
  Options<SmsPostApiV1SmsSendSendSingleSms2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    SmsPostApiV1SmsSendSendSingleSms2Error,
    Options<SmsPostApiV1SmsSendSendSingleSms2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await smsPostApiV1SmsSendSendSingleSms2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const smsPostApiV1SmsSendBulkSendBulkSms2QueryKey = (
  options: Options<SmsPostApiV1SmsSendBulkSendBulkSms2Data>
) => createQueryKey("smsPostApiV1SmsSendBulkSendBulkSms2", options);

/**
 * Send Bulk Sms
 */
export const smsPostApiV1SmsSendBulkSendBulkSms2Options = (
  options: Options<SmsPostApiV1SmsSendBulkSendBulkSms2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await smsPostApiV1SmsSendBulkSendBulkSms2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: smsPostApiV1SmsSendBulkSendBulkSms2QueryKey(options),
  });
};

/**
 * Send Bulk Sms
 */
export const smsPostApiV1SmsSendBulkSendBulkSms2Mutation = (
  options?: Partial<Options<SmsPostApiV1SmsSendBulkSendBulkSms2Data>>
): UseMutationOptions<
  unknown,
  SmsPostApiV1SmsSendBulkSendBulkSms2Error,
  Options<SmsPostApiV1SmsSendBulkSendBulkSms2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    SmsPostApiV1SmsSendBulkSendBulkSms2Error,
    Options<SmsPostApiV1SmsSendBulkSendBulkSms2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await smsPostApiV1SmsSendBulkSendBulkSms2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const applicationGetApiV1SmsBalanceCheckBalance2QueryKey = (
  options?: Options<ApplicationGetApiV1SmsBalanceCheckBalance2Data>
) => createQueryKey("applicationGetApiV1SmsBalanceCheckBalance2", options);

/**
 * Check Balance
 */
export const applicationGetApiV1SmsBalanceCheckBalance2Options = (
  options?: Options<ApplicationGetApiV1SmsBalanceCheckBalance2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await applicationGetApiV1SmsBalanceCheckBalance2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: applicationGetApiV1SmsBalanceCheckBalance2QueryKey(options),
  });
};

export const webhookPostApiV1DeliveryReportHandleDeliveryReport2QueryKey = (
  options?: Options<WebhookPostApiV1DeliveryReportHandleDeliveryReport2Data>
) =>
  createQueryKey(
    "webhookPostApiV1DeliveryReportHandleDeliveryReport2",
    options
  );

/**
 * Handle Delivery Report
 */
export const webhookPostApiV1DeliveryReportHandleDeliveryReport2Options = (
  options?: Options<WebhookPostApiV1DeliveryReportHandleDeliveryReport2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } =
        await webhookPostApiV1DeliveryReportHandleDeliveryReport2({
          ...options,
          ...queryKey[0],
          signal,
          throwOnError: true,
        });
      return data;
    },
    queryKey:
      webhookPostApiV1DeliveryReportHandleDeliveryReport2QueryKey(options),
  });
};

/**
 * Handle Delivery Report
 */
export const webhookPostApiV1DeliveryReportHandleDeliveryReport2Mutation = (
  options?: Partial<
    Options<WebhookPostApiV1DeliveryReportHandleDeliveryReport2Data>
  >
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<WebhookPostApiV1DeliveryReportHandleDeliveryReport2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<WebhookPostApiV1DeliveryReportHandleDeliveryReport2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } =
        await webhookPostApiV1DeliveryReportHandleDeliveryReport2({
          ...options,
          ...localOptions,
          throwOnError: true,
        });
      return data;
    },
  };
  return mutationOptions;
};

export const smsGetApiV1SmsStatusMessageIdGetMessageStatus2QueryKey = (
  options: Options<SmsGetApiV1SmsStatusMessageIdGetMessageStatus2Data>
) => createQueryKey("smsGetApiV1SmsStatusMessageIdGetMessageStatus2", options);

/**
 * Get Message Status
 */
export const smsGetApiV1SmsStatusMessageIdGetMessageStatus2Options = (
  options: Options<SmsGetApiV1SmsStatusMessageIdGetMessageStatus2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await smsGetApiV1SmsStatusMessageIdGetMessageStatus2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: smsGetApiV1SmsStatusMessageIdGetMessageStatus2QueryKey(options),
  });
};

export const apiGetHealthHealthCheck2QueryKey = (
  options?: Options<ApiGetHealthHealthCheck2Data>
) => createQueryKey("apiGetHealthHealthCheck2", options);

/**
 * Health Check
 */
export const apiGetHealthHealthCheck2Options = (
  options?: Options<ApiGetHealthHealthCheck2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetHealthHealthCheck2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetHealthHealthCheck2QueryKey(options),
  });
};

export const apiGetRootRoot6QueryKey = (
  options?: Options<ApiGetRootRoot6Data>
) => createQueryKey("apiGetRootRoot6", options);

/**
 * Root
 */
export const apiGetRootRoot6Options = (
  options?: Options<ApiGetRootRoot6Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetRootRoot6({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetRootRoot6QueryKey(options),
  });
};

export const apiGetMetricsMetrics2QueryKey = (
  options?: Options<ApiGetMetricsMetrics2Data>
) => createQueryKey("apiGetMetricsMetrics2", options);

/**
 * Metrics
 * Endpoint that serves Prometheus metrics.
 */
export const apiGetMetricsMetrics2Options = (
  options?: Options<ApiGetMetricsMetrics2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetMetricsMetrics2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetMetricsMetrics2QueryKey(options),
  });
};

export const healthHealthGetQueryKey = (
  options?: Options<HealthHealthGetData>
) => createQueryKey("healthHealthGet", options);

/**
 * Health
 */
export const healthHealthGetOptions = (
  options?: Options<HealthHealthGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthHealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthHealthGetQueryKey(options),
  });
};

export const readyReadyGet2QueryKey = (options?: Options<ReadyReadyGet2Data>) =>
  createQueryKey("readyReadyGet2", options);

/**
 * Ready
 */
export const readyReadyGet2Options = (
  options?: Options<ReadyReadyGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await readyReadyGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: readyReadyGet2QueryKey(options),
  });
};

export const getModelsApiV1ModelsGroqGet2QueryKey = (
  options?: Options<GetModelsApiV1ModelsGroqGet2Data>
) => createQueryKey("getModelsApiV1ModelsGroqGet2", options);

/**
 * Retrieve available AI models
 * This endpoint returns a list of all available AI models that can be used for generating responses.
 *
 * **Behavior**:
 * - Fetches all currently supported models from the Groq AI platform.
 * - Returns the models as a simple list of strings (model names or IDs).
 * - No authentication is required for anonymous access (optional to add auth later).
 *
 * **Response**:
 * - `200 OK`: A JSON list of model names/IDs, for example:
 * ```json
 * [
 * {
 * "id": "meta-llama/llama-4-maverick-17b-128e-instruct",
 * "owned_by": "Meta",
 * "active": true,
 * "context_window": 131072,
 * "max_completion_tokens": 8192
 * }
 * ]
 * ```
 *
 * **Notes**:
 * - This list is dynamic and may change as new models are added or deprecated.
 * - Clients can use these model IDs when making requests to the `/chat/` endpoint.
 */
export const getModelsApiV1ModelsGroqGet2Options = (
  options?: Options<GetModelsApiV1ModelsGroqGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getModelsApiV1ModelsGroqGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getModelsApiV1ModelsGroqGet2QueryKey(options),
  });
};

export const getOpenaiModelsApiV1ModelsOpenaiGet2QueryKey = (
  options?: Options<GetOpenaiModelsApiV1ModelsOpenaiGet2Data>
) => createQueryKey("getOpenaiModelsApiV1ModelsOpenaiGet2", options);

/**
 * Retrieve available OpenAI models
 * This endpoint returns a list of all available OpenAI models that can be used for generating responses.
 *
 * **Behavior**:
 * - Fetches all currently supported models from the OpenAI platform.
 * - Returns the models as a simple list of strings (model names or IDs).
 * - No authentication is required for anonymous access (optional to add auth later).
 *
 * **Response**:
 * - `200 OK`: A JSON list of model names/IDs, for example:
 * ```json
 * [
 * {
 * "id": "gpt-4",
 * "owned_by": "openai",
 * "active": true,
 * "context_window": 8192,
 * "max_completion_tokens": 4096
 * }
 * ]
 * ```
 *
 * **Notes**:
 * - This list is dynamic and may change as new models are added or deprecated.
 * - Clients can use these model IDs when making requests to the `/chat/` endpoint.
 */
export const getOpenaiModelsApiV1ModelsOpenaiGet2Options = (
  options?: Options<GetOpenaiModelsApiV1ModelsOpenaiGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getOpenaiModelsApiV1ModelsOpenaiGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getOpenaiModelsApiV1ModelsOpenaiGet2QueryKey(options),
  });
};

export const chatApiV1ChatPost2QueryKey = (
  options: Options<ChatApiV1ChatPost2Data>
) => createQueryKey("chatApiV1ChatPost2", options);

/**
 * Send a message to the AI and receive a response
 * This endpoint allows the user to send a message to the AI model and receive a response.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Behavior**:
 * - If `session_id` is provided, the message will be added to that session.
 * - If `session_id` is not provided, a new session will be created automatically.
 * - The AI response is generated using the specified model and parameters.
 *
 * **Request Body Parameters**:
 * - `model_id` (optional, string): The AI model to use for generating responses. Defaults to the platform default if not provided.
 * - `session_id` (optional, string): Existing chat session ID. Leave empty to start a new session.
 * - `user_input` (required, string): The message text you want the AI to respond to.
 * - `is_openai` (optional, boolean): Set `True` to use OpenAI API; `False` to use internal AI model. Defaults to `False`.
 * - `temperature` (optional, float): Controls randomness of AI responses (0 = deterministic, 1 = creative). Default is 0.0.
 * - `max_tokens` (optional, int): Maximum tokens allowed in AI response. Defaults to 2000.
 * - `system_prompt` (optional, string): Custom system prompt to guide AI behavior.
 *
 * **Response**:
 * - `chat_messages` (list of messages): Contains both user and AI messages with timestamps and token usage.
 * - `session_id` (string): The session ID for the conversation.
 * - `is_openai` (boolean): Indicates which AI engine generated the response.
 * - `session_total_tokens` (int): The accumulated tokens used in this session.
 */
export const chatApiV1ChatPost2Options = (
  options: Options<ChatApiV1ChatPost2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await chatApiV1ChatPost2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: chatApiV1ChatPost2QueryKey(options),
  });
};

/**
 * Send a message to the AI and receive a response
 * This endpoint allows the user to send a message to the AI model and receive a response.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Behavior**:
 * - If `session_id` is provided, the message will be added to that session.
 * - If `session_id` is not provided, a new session will be created automatically.
 * - The AI response is generated using the specified model and parameters.
 *
 * **Request Body Parameters**:
 * - `model_id` (optional, string): The AI model to use for generating responses. Defaults to the platform default if not provided.
 * - `session_id` (optional, string): Existing chat session ID. Leave empty to start a new session.
 * - `user_input` (required, string): The message text you want the AI to respond to.
 * - `is_openai` (optional, boolean): Set `True` to use OpenAI API; `False` to use internal AI model. Defaults to `False`.
 * - `temperature` (optional, float): Controls randomness of AI responses (0 = deterministic, 1 = creative). Default is 0.0.
 * - `max_tokens` (optional, int): Maximum tokens allowed in AI response. Defaults to 2000.
 * - `system_prompt` (optional, string): Custom system prompt to guide AI behavior.
 *
 * **Response**:
 * - `chat_messages` (list of messages): Contains both user and AI messages with timestamps and token usage.
 * - `session_id` (string): The session ID for the conversation.
 * - `is_openai` (boolean): Indicates which AI engine generated the response.
 * - `session_total_tokens` (int): The accumulated tokens used in this session.
 */
export const chatApiV1ChatPost2Mutation = (
  options?: Partial<Options<ChatApiV1ChatPost2Data>>
): UseMutationOptions<
  ChatApiV1ChatPost2Response,
  ChatApiV1ChatPost2Error,
  Options<ChatApiV1ChatPost2Data>
> => {
  const mutationOptions: UseMutationOptions<
    ChatApiV1ChatPost2Response,
    ChatApiV1ChatPost2Error,
    Options<ChatApiV1ChatPost2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await chatApiV1ChatPost2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const getChatHistoryApiV1ChatSessionIdSessionGet2QueryKey = (
  options: Options<GetChatHistoryApiV1ChatSessionIdSessionGet2Data>
) => createQueryKey("getChatHistoryApiV1ChatSessionIdSessionGet2", options);

/**
 * Retrieve the chat history for a session
 * Fetches all messages for a specific chat session.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Path Parameters**:
 * - `session_id` (string, required): The ID of the session whose messages you want to retrieve.
 *
 * **Response**:
 * - `chat_messages` (list of messages): Messages in chronological order.
 * - `session_id` (string): The session ID.
 * - `is_openai` (boolean): Always `False` for retrieved messages.
 * - `session_total_tokens` (int): The accumulated tokens used in this session.
 *
 * **Errors**:
 * - `404 Not Found`: If the session does not exist.
 * - `500 Internal Server Error`: If there is a server/database error.
 */
export const getChatHistoryApiV1ChatSessionIdSessionGet2Options = (
  options: Options<GetChatHistoryApiV1ChatSessionIdSessionGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getChatHistoryApiV1ChatSessionIdSessionGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getChatHistoryApiV1ChatSessionIdSessionGet2QueryKey(options),
  });
};

export const getChatSessionsApiV1ChatSessionsAllGet2QueryKey = (
  options?: Options<GetChatSessionsApiV1ChatSessionsAllGet2Data>
) => createQueryKey("getChatSessionsApiV1ChatSessionsAllGet2", options);

/**
 * Get all chat sessions
 * Returns a list of all chat sessions for the authenticated user.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Response**:
 * - List of `ChatSession` objects, each containing session metadata and associated messages.
 */
export const getChatSessionsApiV1ChatSessionsAllGet2Options = (
  options?: Options<GetChatSessionsApiV1ChatSessionsAllGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getChatSessionsApiV1ChatSessionsAllGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getChatSessionsApiV1ChatSessionsAllGet2QueryKey(options),
  });
};

export const queryRagApiV1RagQueryPost2QueryKey = (
  options: Options<QueryRagApiV1RagQueryPost2Data>
) => createQueryKey("queryRagApiV1RagQueryPost2", options);

/**
 * Query the RAG (Retrieval-Augmented Generation) system
 * This endpoint allows users to query the RAG system, which combines a vector database
 * with a language model to generate answers based on uploaded documents.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `user_request.query` (str): The text query you want the system to answer.
 * - `user_request.model_id` (Optional[str]): The ID of the LLM model to use. If not provided, the default model is used.
 * - `user_request.system_prompt` (Optional[str]): Optional custom system prompt to influence the answer.
 *
 * **Behavior:**
 * - Uses the embedding model stored in the application state to retrieve relevant documents.
 * - Passes the retrieved context along with the query to the specified LLM.
 * - Returns the generated answer.
 *
 * **Response:**
 * ```json
 * {
 * "answer": "The system-generated answer based on your query and documents."
 * }
 * ```
 */
export const queryRagApiV1RagQueryPost2Options = (
  options: Options<QueryRagApiV1RagQueryPost2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await queryRagApiV1RagQueryPost2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: queryRagApiV1RagQueryPost2QueryKey(options),
  });
};

/**
 * Query the RAG (Retrieval-Augmented Generation) system
 * This endpoint allows users to query the RAG system, which combines a vector database
 * with a language model to generate answers based on uploaded documents.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `user_request.query` (str): The text query you want the system to answer.
 * - `user_request.model_id` (Optional[str]): The ID of the LLM model to use. If not provided, the default model is used.
 * - `user_request.system_prompt` (Optional[str]): Optional custom system prompt to influence the answer.
 *
 * **Behavior:**
 * - Uses the embedding model stored in the application state to retrieve relevant documents.
 * - Passes the retrieved context along with the query to the specified LLM.
 * - Returns the generated answer.
 *
 * **Response:**
 * ```json
 * {
 * "answer": "The system-generated answer based on your query and documents."
 * }
 * ```
 */
export const queryRagApiV1RagQueryPost2Mutation = (
  options?: Partial<Options<QueryRagApiV1RagQueryPost2Data>>
): UseMutationOptions<
  QueryRagApiV1RagQueryPost2Response,
  QueryRagApiV1RagQueryPost2Error,
  Options<QueryRagApiV1RagQueryPost2Data>
> => {
  const mutationOptions: UseMutationOptions<
    QueryRagApiV1RagQueryPost2Response,
    QueryRagApiV1RagQueryPost2Error,
    Options<QueryRagApiV1RagQueryPost2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await queryRagApiV1RagQueryPost2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const uploadForRagApiV1RagUploadPost2QueryKey = (
  options: Options<UploadForRagApiV1RagUploadPost2Data>
) => createQueryKey("uploadForRagApiV1RagUploadPost2", options);

/**
 * Upload documents for RAG system
 * This endpoint allows users to upload documents (PDFs, text files, etc.)
 * that will be processed and embedded for retrieval by the RAG system.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `files` (List[UploadFile]): A list of files to upload. Multiple files can be uploaded at once.
 *
 * **Behavior:**
 * - Embeds the uploaded documents using the system's embedding model.
 * - Stores them in the vector database for later retrieval.
 * - Each document is associated with the user ID (currently using 'anonymous').
 *
 * **Response:**
 * ```json
 * {
 * "status": "success",
 * "uploaded_files": ["file1.pdf", "file2.txt"]
 * }
 * ```
 */
export const uploadForRagApiV1RagUploadPost2Options = (
  options: Options<UploadForRagApiV1RagUploadPost2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await uploadForRagApiV1RagUploadPost2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: uploadForRagApiV1RagUploadPost2QueryKey(options),
  });
};

/**
 * Upload documents for RAG system
 * This endpoint allows users to upload documents (PDFs, text files, etc.)
 * that will be processed and embedded for retrieval by the RAG system.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `files` (List[UploadFile]): A list of files to upload. Multiple files can be uploaded at once.
 *
 * **Behavior:**
 * - Embeds the uploaded documents using the system's embedding model.
 * - Stores them in the vector database for later retrieval.
 * - Each document is associated with the user ID (currently using 'anonymous').
 *
 * **Response:**
 * ```json
 * {
 * "status": "success",
 * "uploaded_files": ["file1.pdf", "file2.txt"]
 * }
 * ```
 */
export const uploadForRagApiV1RagUploadPost2Mutation = (
  options?: Partial<Options<UploadForRagApiV1RagUploadPost2Data>>
): UseMutationOptions<
  UploadForRagApiV1RagUploadPost2Response,
  UploadForRagApiV1RagUploadPost2Error,
  Options<UploadForRagApiV1RagUploadPost2Data>
> => {
  const mutationOptions: UseMutationOptions<
    UploadForRagApiV1RagUploadPost2Response,
    UploadForRagApiV1RagUploadPost2Error,
    Options<UploadForRagApiV1RagUploadPost2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await uploadForRagApiV1RagUploadPost2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const speechToTextApiV1SpitchSpeechToTextPost2QueryKey = (
  options: Options<SpeechToTextApiV1SpitchSpeechToTextPost2Data>
) => createQueryKey("speechToTextApiV1SpitchSpeechToTextPost2", options);

/**
 * Transcribe audio to text
 * Convert an audio file into written text.
 *
 * **Parameters:**
 * - `file` (UploadFile): The audio file to transcribe. Supported formats include mp3, wav, etc.
 * - `language` (str, optional): Language code of the audio. Defaults to 'en' (English).
 * - `model` (str, optional): The transcription model to use. Defaults to 'mansa_v1'.
 *
 * **Returns:**
 * - `text` (str): The transcribed text from the audio.
 */
export const speechToTextApiV1SpitchSpeechToTextPost2Options = (
  options: Options<SpeechToTextApiV1SpitchSpeechToTextPost2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await speechToTextApiV1SpitchSpeechToTextPost2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: speechToTextApiV1SpitchSpeechToTextPost2QueryKey(options),
  });
};

/**
 * Transcribe audio to text
 * Convert an audio file into written text.
 *
 * **Parameters:**
 * - `file` (UploadFile): The audio file to transcribe. Supported formats include mp3, wav, etc.
 * - `language` (str, optional): Language code of the audio. Defaults to 'en' (English).
 * - `model` (str, optional): The transcription model to use. Defaults to 'mansa_v1'.
 *
 * **Returns:**
 * - `text` (str): The transcribed text from the audio.
 */
export const speechToTextApiV1SpitchSpeechToTextPost2Mutation = (
  options?: Partial<Options<SpeechToTextApiV1SpitchSpeechToTextPost2Data>>
): UseMutationOptions<
  unknown,
  SpeechToTextApiV1SpitchSpeechToTextPost2Error,
  Options<SpeechToTextApiV1SpitchSpeechToTextPost2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    SpeechToTextApiV1SpitchSpeechToTextPost2Error,
    Options<SpeechToTextApiV1SpitchSpeechToTextPost2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await speechToTextApiV1SpitchSpeechToTextPost2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const textToSpeechApiV1SpitchTextToSpeechPost2QueryKey = (
  options: Options<TextToSpeechApiV1SpitchTextToSpeechPost2Data>
) => createQueryKey("textToSpeechApiV1SpitchTextToSpeechPost2", options);

/**
 * Generate speech from text
 * Convert input text into spoken audio (speech).
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `text` (str): The text content to convert to speech.
 * - `language` (str, optional): Language code for speech generation. Defaults to 'en'.
 * - `voice` (str, optional): The voice to use for speech. Defaults to 'lina'.
 *
 * **Returns:**
 * - An audio file (MP3) containing the spoken text.
 */
export const textToSpeechApiV1SpitchTextToSpeechPost2Options = (
  options: Options<TextToSpeechApiV1SpitchTextToSpeechPost2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await textToSpeechApiV1SpitchTextToSpeechPost2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: textToSpeechApiV1SpitchTextToSpeechPost2QueryKey(options),
  });
};

/**
 * Generate speech from text
 * Convert input text into spoken audio (speech).
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `text` (str): The text content to convert to speech.
 * - `language` (str, optional): Language code for speech generation. Defaults to 'en'.
 * - `voice` (str, optional): The voice to use for speech. Defaults to 'lina'.
 *
 * **Returns:**
 * - An audio file (MP3) containing the spoken text.
 */
export const textToSpeechApiV1SpitchTextToSpeechPost2Mutation = (
  options?: Partial<Options<TextToSpeechApiV1SpitchTextToSpeechPost2Data>>
): UseMutationOptions<
  unknown,
  TextToSpeechApiV1SpitchTextToSpeechPost2Error,
  Options<TextToSpeechApiV1SpitchTextToSpeechPost2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    TextToSpeechApiV1SpitchTextToSpeechPost2Error,
    Options<TextToSpeechApiV1SpitchTextToSpeechPost2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await textToSpeechApiV1SpitchTextToSpeechPost2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const translateApiV1SpitchTranslatePost2QueryKey = (
  options: Options<TranslateApiV1SpitchTranslatePost2Data>
) => createQueryKey("translateApiV1SpitchTranslatePost2", options);

/**
 * Translate text between languages
 * Translate input text from a source language to a target language.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `text` (str): The text content to translate.
 * - `source` (str, optional): Source language code. Defaults to 'en' (English).
 * - `target` (str, optional): Target language code. Defaults to 'yo' (Yoruba).
 *
 * **Returns:**
 * - `translation` (str): The translated text.
 */
export const translateApiV1SpitchTranslatePost2Options = (
  options: Options<TranslateApiV1SpitchTranslatePost2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await translateApiV1SpitchTranslatePost2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: translateApiV1SpitchTranslatePost2QueryKey(options),
  });
};

/**
 * Translate text between languages
 * Translate input text from a source language to a target language.
 *
 * **Authentication**:
 * - Requires a valid JWT access token in the `Authorization: Bearer <token>` header.
 * - Tokens are issued by the Auth service: `POST /api/v1/auth/login`
 *
 * **Parameters:**
 * - `text` (str): The text content to translate.
 * - `source` (str, optional): Source language code. Defaults to 'en' (English).
 * - `target` (str, optional): Target language code. Defaults to 'yo' (Yoruba).
 *
 * **Returns:**
 * - `translation` (str): The translated text.
 */
export const translateApiV1SpitchTranslatePost2Mutation = (
  options?: Partial<Options<TranslateApiV1SpitchTranslatePost2Data>>
): UseMutationOptions<
  unknown,
  TranslateApiV1SpitchTranslatePost2Error,
  Options<TranslateApiV1SpitchTranslatePost2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    TranslateApiV1SpitchTranslatePost2Error,
    Options<TranslateApiV1SpitchTranslatePost2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await translateApiV1SpitchTranslatePost2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const rootGet2QueryKey = (options?: Options<RootGet2Data>) =>
  createQueryKey("rootGet2", options);

/**
 * Root
 */
export const rootGet2Options = (options?: Options<RootGet2Data>) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await rootGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: rootGet2QueryKey(options),
  });
};

export const metricsMetricsGetQueryKey = (
  options?: Options<MetricsMetricsGetData>
) => createQueryKey("metricsMetricsGet", options);

/**
 * Metrics
 * Endpoint that serves Prometheus metrics.
 */
export const metricsMetricsGetOptions = (
  options?: Options<MetricsMetricsGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await metricsMetricsGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: metricsMetricsGetQueryKey(options),
  });
};

export const getNearbyPlacesApiV1MapsNearbyGet2QueryKey = (
  options: Options<GetNearbyPlacesApiV1MapsNearbyGet2Data>
) => createQueryKey("getNearbyPlacesApiV1MapsNearbyGet2", options);

/**
 * Get Nearby Places
 * Search for nearby places around a given location. Returns distance in meters.
 *
 * Args:
 * lat (float): Latitude of the location.
 * lng (float): Longitude of the location.
 * keyword (str, optional): Search keyword (e.g., "hospital", "pharmacy").
 * Default is "hospital".
 * radius_m (int, optional): Search radius in meters. Default is 2000.
 *
 * Returns:
 * list: Places with details from Google Maps, including a direct Maps URL.
 */
export const getNearbyPlacesApiV1MapsNearbyGet2Options = (
  options: Options<GetNearbyPlacesApiV1MapsNearbyGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getNearbyPlacesApiV1MapsNearbyGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getNearbyPlacesApiV1MapsNearbyGet2QueryKey(options),
  });
};

export const getDistanceApiV1MapsDistanceGet2QueryKey = (
  options: Options<GetDistanceApiV1MapsDistanceGet2Data>
) => createQueryKey("getDistanceApiV1MapsDistanceGet2", options);

/**
 * Get Distance
 * Get travel distance and duration between two locations. Returns distance in meters and duration in seconds.
 *
 * Args:
 * origin (str): Starting point (address or "lat,lng").
 * destination (str): End point (address or "lat,lng").
 * mode (str, optional): Travel mode ("driving", "walking", "bicycling", "transit").
 * Default is "driving".
 *
 * Returns:
 * dict: Distance matrix response with distance and duration details.
 */
export const getDistanceApiV1MapsDistanceGet2Options = (
  options: Options<GetDistanceApiV1MapsDistanceGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDistanceApiV1MapsDistanceGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDistanceApiV1MapsDistanceGet2QueryKey(options),
  });
};

export const getDirectionsApiV1MapsDirectionsGet2QueryKey = (
  options: Options<GetDirectionsApiV1MapsDirectionsGet2Data>
) => createQueryKey("getDirectionsApiV1MapsDirectionsGet2", options);

/**
 * Get Directions
 * Get directions between two locations. Returned distance in meters and duration in seconds.
 *
 * Args:
 * origin (str): Starting point (address or "lat,lng").
 * destination (str): End point (address or "lat,lng").
 * mode (str, optional): Travel mode ("driving", "walking", "bicycling", "transit").
 * Default is "driving".
 *
 * Returns:
 * list: Routes with legs, steps, distance, duration, and polyline.
 */
export const getDirectionsApiV1MapsDirectionsGet2Options = (
  options: Options<GetDirectionsApiV1MapsDirectionsGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getDirectionsApiV1MapsDirectionsGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getDirectionsApiV1MapsDirectionsGet2QueryKey(options),
  });
};

export const getStaticMapApiV1MapsStaticGet2QueryKey = (
  options: Options<GetStaticMapApiV1MapsStaticGet2Data>
) => createQueryKey("getStaticMapApiV1MapsStaticGet2", options);

/**
 * Get Static Map
 * Generate and stream a Google Static Map image with optional markers and path.
 * The API key is not exposed to the client.
 *
 * Args:
 * center (str): Map center (e.g., "New York,NY" or "lat,lng").
 * markers (list[str], optional): Marker coordinates/labels.
 * Example: `&markers=color:blue|label:S|37.421655,-122.085637`
 * path (list[str], optional): Coordinates for a polyline path.
 * Example: `&path=color:0xff0000ff|weight:5|37.421655,-122.085637|37.420999,-122.086894`
 * zoom (int, optional): Zoom level (default 14).
 *
 * Returns:
 * StreamingResponse: The map image as a PNG stream.
 */
export const getStaticMapApiV1MapsStaticGet2Options = (
  options: Options<GetStaticMapApiV1MapsStaticGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getStaticMapApiV1MapsStaticGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getStaticMapApiV1MapsStaticGet2QueryKey(options),
  });
};

export const getRouteApiV1MapsRoutesPost2QueryKey = (
  options: Options<GetRouteApiV1MapsRoutesPost2Data>
) => createQueryKey("getRouteApiV1MapsRoutesPost2", options);

/**
 * Get Route
 * Compute a driving route between an origin and a destination.
 *
 * Args:
 * request (RouteRequest): Request object containing origin, destination,
 * travel mode, routing preferences, and modifiers.
 *
 * Returns:
 * dict: Route details including duration, distance (meters), encoded polyline,
 * decoded coordinates (if polyline lib installed), and route legs.
 * Returns error info if the request fails or no route is found.
 */
export const getRouteApiV1MapsRoutesPost2Options = (
  options: Options<GetRouteApiV1MapsRoutesPost2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await getRouteApiV1MapsRoutesPost2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: getRouteApiV1MapsRoutesPost2QueryKey(options),
  });
};

/**
 * Get Route
 * Compute a driving route between an origin and a destination.
 *
 * Args:
 * request (RouteRequest): Request object containing origin, destination,
 * travel mode, routing preferences, and modifiers.
 *
 * Returns:
 * dict: Route details including duration, distance (meters), encoded polyline,
 * decoded coordinates (if polyline lib installed), and route legs.
 * Returns error info if the request fails or no route is found.
 */
export const getRouteApiV1MapsRoutesPost2Mutation = (
  options?: Partial<Options<GetRouteApiV1MapsRoutesPost2Data>>
): UseMutationOptions<
  unknown,
  GetRouteApiV1MapsRoutesPost2Error,
  Options<GetRouteApiV1MapsRoutesPost2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    GetRouteApiV1MapsRoutesPost2Error,
    Options<GetRouteApiV1MapsRoutesPost2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await getRouteApiV1MapsRoutesPost2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const healthCheckHealthGetQueryKey = (
  options?: Options<HealthCheckHealthGetData>
) => createQueryKey("healthCheckHealthGet", options);

/**
 * Health Check
 * Health check endpoint.
 */
export const healthCheckHealthGetOptions = (
  options?: Options<HealthCheckHealthGetData>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await healthCheckHealthGet({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: healthCheckHealthGetQueryKey(options),
  });
};

export const metricsMetricsGet2QueryKey = (
  options?: Options<MetricsMetricsGet2Data>
) => createQueryKey("metricsMetricsGet2", options);

/**
 * Metrics
 */
export const metricsMetricsGet2Options = (
  options?: Options<MetricsMetricsGet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await metricsMetricsGet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: metricsMetricsGet2QueryKey(options),
  });
};

export const apiGetHealthHealthCheck3QueryKey = (
  options?: Options<ApiGetHealthHealthCheck3Data>
) => createQueryKey("apiGetHealthHealthCheck3", options);

/**
 * Health Check
 */
export const apiGetHealthHealthCheck3Options = (
  options?: Options<ApiGetHealthHealthCheck3Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetHealthHealthCheck3({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetHealthHealthCheck3QueryKey(options),
  });
};

export const apiPostUssdUssdProxy2QueryKey = (
  options?: Options<ApiPostUssdUssdProxy2Data>
) => createQueryKey("apiPostUssdUssdProxy2", options);

/**
 * Ussd Proxy
 * This is the USSD gateway proxy endpoint. It receives the request from Africa's Talking
 * and forwards it to the correct client's callback URL based on the serviceCode.
 */
export const apiPostUssdUssdProxy2Options = (
  options?: Options<ApiPostUssdUssdProxy2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiPostUssdUssdProxy2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiPostUssdUssdProxy2QueryKey(options),
  });
};

/**
 * Ussd Proxy
 * This is the USSD gateway proxy endpoint. It receives the request from Africa's Talking
 * and forwards it to the correct client's callback URL based on the serviceCode.
 */
export const apiPostUssdUssdProxy2Mutation = (
  options?: Partial<Options<ApiPostUssdUssdProxy2Data>>
): UseMutationOptions<
  unknown,
  ApiPostUssdUssdProxy2Error,
  Options<ApiPostUssdUssdProxy2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ApiPostUssdUssdProxy2Error,
    Options<ApiPostUssdUssdProxy2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await apiPostUssdUssdProxy2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const apiPostUssdNotificationUssdNotification2QueryKey = (
  options?: Options<ApiPostUssdNotificationUssdNotification2Data>
) => createQueryKey("apiPostUssdNotificationUssdNotification2", options);

/**
 * Ussd Notification
 * Handles end-of-session USSD notifications.
 * This endpoint is for receiving the final summary of a session.
 */
export const apiPostUssdNotificationUssdNotification2Options = (
  options?: Options<ApiPostUssdNotificationUssdNotification2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiPostUssdNotificationUssdNotification2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiPostUssdNotificationUssdNotification2QueryKey(options),
  });
};

/**
 * Ussd Notification
 * Handles end-of-session USSD notifications.
 * This endpoint is for receiving the final summary of a session.
 */
export const apiPostUssdNotificationUssdNotification2Mutation = (
  options?: Partial<Options<ApiPostUssdNotificationUssdNotification2Data>>
): UseMutationOptions<
  unknown,
  ApiPostUssdNotificationUssdNotification2Error,
  Options<ApiPostUssdNotificationUssdNotification2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    ApiPostUssdNotificationUssdNotification2Error,
    Options<ApiPostUssdNotificationUssdNotification2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await apiPostUssdNotificationUssdNotification2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV18MedicalUssdCallback8Medical2QueryKey = (
  options?: Options<UssdPostApiV18MedicalUssdCallback8Medical2Data>
) => createQueryKey("ussdPostApiV18MedicalUssdCallback8Medical2", options);

/**
 * Callback 8Medical
 * This endpoint simulates 8Medical_USSD's application server without signature verification.
 */
export const ussdPostApiV18MedicalUssdCallback8Medical2Options = (
  options?: Options<UssdPostApiV18MedicalUssdCallback8Medical2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV18MedicalUssdCallback8Medical2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV18MedicalUssdCallback8Medical2QueryKey(options),
  });
};

/**
 * Callback 8Medical
 * This endpoint simulates 8Medical_USSD's application server without signature verification.
 */
export const ussdPostApiV18MedicalUssdCallback8Medical2Mutation = (
  options?: Partial<Options<UssdPostApiV18MedicalUssdCallback8Medical2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV18MedicalUssdCallback8Medical2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV18MedicalUssdCallback8Medical2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV18MedicalUssdCallback8Medical2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1AlajoUssdCallbackAlajo2QueryKey = (
  options?: Options<UssdPostApiV1AlajoUssdCallbackAlajo2Data>
) => createQueryKey("ussdPostApiV1AlajoUssdCallbackAlajo2", options);

/**
 * Callback Alajo
 * This endpoint simulates Alajo_USSD's application server without signature verification.
 */
export const ussdPostApiV1AlajoUssdCallbackAlajo2Options = (
  options?: Options<UssdPostApiV1AlajoUssdCallbackAlajo2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1AlajoUssdCallbackAlajo2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1AlajoUssdCallbackAlajo2QueryKey(options),
  });
};

/**
 * Callback Alajo
 * This endpoint simulates Alajo_USSD's application server without signature verification.
 */
export const ussdPostApiV1AlajoUssdCallbackAlajo2Mutation = (
  options?: Partial<Options<UssdPostApiV1AlajoUssdCallbackAlajo2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1AlajoUssdCallbackAlajo2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1AlajoUssdCallbackAlajo2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1AlajoUssdCallbackAlajo2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1ClafiyaUssdCallbackClafiya2QueryKey = (
  options?: Options<UssdPostApiV1ClafiyaUssdCallbackClafiya2Data>
) => createQueryKey("ussdPostApiV1ClafiyaUssdCallbackClafiya2", options);

/**
 * Callback Clafiya
 * This endpoint simulates Clafiya_USSD's application server without signature verification.
 */
export const ussdPostApiV1ClafiyaUssdCallbackClafiya2Options = (
  options?: Options<UssdPostApiV1ClafiyaUssdCallbackClafiya2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1ClafiyaUssdCallbackClafiya2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1ClafiyaUssdCallbackClafiya2QueryKey(options),
  });
};

/**
 * Callback Clafiya
 * This endpoint simulates Clafiya_USSD's application server without signature verification.
 */
export const ussdPostApiV1ClafiyaUssdCallbackClafiya2Mutation = (
  options?: Partial<Options<UssdPostApiV1ClafiyaUssdCallbackClafiya2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1ClafiyaUssdCallbackClafiya2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1ClafiyaUssdCallbackClafiya2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1ClafiyaUssdCallbackClafiya2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1EvetUssdCallbackEvet2QueryKey = (
  options?: Options<UssdPostApiV1EvetUssdCallbackEvet2Data>
) => createQueryKey("ussdPostApiV1EvetUssdCallbackEvet2", options);

/**
 * Callback Evet
 * This endpoint simulates Evet_USSD's application server without signature verification.
 */
export const ussdPostApiV1EvetUssdCallbackEvet2Options = (
  options?: Options<UssdPostApiV1EvetUssdCallbackEvet2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1EvetUssdCallbackEvet2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1EvetUssdCallbackEvet2QueryKey(options),
  });
};

/**
 * Callback Evet
 * This endpoint simulates Evet_USSD's application server without signature verification.
 */
export const ussdPostApiV1EvetUssdCallbackEvet2Mutation = (
  options?: Partial<Options<UssdPostApiV1EvetUssdCallbackEvet2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1EvetUssdCallbackEvet2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1EvetUssdCallbackEvet2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1EvetUssdCallbackEvet2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1FertitudeUssdCallbackFertitude2QueryKey = (
  options?: Options<UssdPostApiV1FertitudeUssdCallbackFertitude2Data>
) => createQueryKey("ussdPostApiV1FertitudeUssdCallbackFertitude2", options);

/**
 * Callback Fertitude
 * This endpoint simulates Fertitude_USSD's application server without signature verification.
 */
export const ussdPostApiV1FertitudeUssdCallbackFertitude2Options = (
  options?: Options<UssdPostApiV1FertitudeUssdCallbackFertitude2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1FertitudeUssdCallbackFertitude2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1FertitudeUssdCallbackFertitude2QueryKey(options),
  });
};

/**
 * Callback Fertitude
 * This endpoint simulates Fertitude_USSD's application server without signature verification.
 */
export const ussdPostApiV1FertitudeUssdCallbackFertitude2Mutation = (
  options?: Partial<Options<UssdPostApiV1FertitudeUssdCallbackFertitude2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1FertitudeUssdCallbackFertitude2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1FertitudeUssdCallbackFertitude2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1FertitudeUssdCallbackFertitude2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1FologUssdCallbackFolog2QueryKey = (
  options?: Options<UssdPostApiV1FologUssdCallbackFolog2Data>
) => createQueryKey("ussdPostApiV1FologUssdCallbackFolog2", options);

/**
 * Callback Folog
 * This endpoint simulates Folog_USSD's application server without signature verification.
 */
export const ussdPostApiV1FologUssdCallbackFolog2Options = (
  options?: Options<UssdPostApiV1FologUssdCallbackFolog2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1FologUssdCallbackFolog2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1FologUssdCallbackFolog2QueryKey(options),
  });
};

/**
 * Callback Folog
 * This endpoint simulates Folog_USSD's application server without signature verification.
 */
export const ussdPostApiV1FologUssdCallbackFolog2Mutation = (
  options?: Partial<Options<UssdPostApiV1FologUssdCallbackFolog2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1FologUssdCallbackFolog2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1FologUssdCallbackFolog2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1FologUssdCallbackFolog2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1MylturaUssdCallbackMyltura2QueryKey = (
  options?: Options<UssdPostApiV1MylturaUssdCallbackMyltura2Data>
) => createQueryKey("ussdPostApiV1MylturaUssdCallbackMyltura2", options);

/**
 * Callback Myltura
 * This endpoint simulates Myltura_USSD's application server without signature verification.
 */
export const ussdPostApiV1MylturaUssdCallbackMyltura2Options = (
  options?: Options<UssdPostApiV1MylturaUssdCallbackMyltura2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1MylturaUssdCallbackMyltura2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1MylturaUssdCallbackMyltura2QueryKey(options),
  });
};

/**
 * Callback Myltura
 * This endpoint simulates Myltura_USSD's application server without signature verification.
 */
export const ussdPostApiV1MylturaUssdCallbackMyltura2Mutation = (
  options?: Partial<Options<UssdPostApiV1MylturaUssdCallbackMyltura2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1MylturaUssdCallbackMyltura2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1MylturaUssdCallbackMyltura2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1MylturaUssdCallbackMyltura2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1UhcTechUssdCallbackUhcTech2QueryKey = (
  options?: Options<UssdPostApiV1UhcTechUssdCallbackUhcTech2Data>
) => createQueryKey("ussdPostApiV1UhcTechUssdCallbackUhcTech2", options);

/**
 * Callback Uhc Tech
 * This endpoint simulates UHC_Tech_USSD's application server without signature verification.
 */
export const ussdPostApiV1UhcTechUssdCallbackUhcTech2Options = (
  options?: Options<UssdPostApiV1UhcTechUssdCallbackUhcTech2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1UhcTechUssdCallbackUhcTech2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1UhcTechUssdCallbackUhcTech2QueryKey(options),
  });
};

/**
 * Callback Uhc Tech
 * This endpoint simulates UHC_Tech_USSD's application server without signature verification.
 */
export const ussdPostApiV1UhcTechUssdCallbackUhcTech2Mutation = (
  options?: Partial<Options<UssdPostApiV1UhcTechUssdCallbackUhcTech2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1UhcTechUssdCallbackUhcTech2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1UhcTechUssdCallbackUhcTech2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1UhcTechUssdCallbackUhcTech2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1XboxUssdCallbackXbox2QueryKey = (
  options?: Options<UssdPostApiV1XboxUssdCallbackXbox2Data>
) => createQueryKey("ussdPostApiV1XboxUssdCallbackXbox2", options);

/**
 * Callback Xbox
 * This endpoint simulates XBOX_USSD's application server without signature verification.
 */
export const ussdPostApiV1XboxUssdCallbackXbox2Options = (
  options?: Options<UssdPostApiV1XboxUssdCallbackXbox2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1XboxUssdCallbackXbox2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1XboxUssdCallbackXbox2QueryKey(options),
  });
};

/**
 * Callback Xbox
 * This endpoint simulates XBOX_USSD's application server without signature verification.
 */
export const ussdPostApiV1XboxUssdCallbackXbox2Mutation = (
  options?: Partial<Options<UssdPostApiV1XboxUssdCallbackXbox2Data>>
): UseMutationOptions<
  unknown,
  DefaultError,
  Options<UssdPostApiV1XboxUssdCallbackXbox2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    DefaultError,
    Options<UssdPostApiV1XboxUssdCallbackXbox2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1XboxUssdCallbackXbox2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestFertitudeUssdTestFertitudeUssd2QueryKey = (
  options: Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Data>
) =>
  createQueryKey("ussdPostApiV1TestFertitudeUssdTestFertitudeUssd2", options);

/**
 * Test Fertitude Ussd
 * Test endpoint for Fertitude USSD logic.
 * Accepts POST form data and returns the same response as /fertitude_ussd.
 *
 *
 * Requires:
 *
 * sessionId e.g., lirwf23455
 *
 * phoneNumber e.g., +2348103317200
 *
 * text (location of interest in the pipeline) e.g., "" (empty for first interaction), "1", "1*1", etc. like you would interact with USSD codes
 */
export const ussdPostApiV1TestFertitudeUssdTestFertitudeUssd2Options = (
  options: Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestFertitudeUssdTestFertitudeUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestFertitudeUssdTestFertitudeUssd2QueryKey(options),
  });
};

/**
 * Test Fertitude Ussd
 * Test endpoint for Fertitude USSD logic.
 * Accepts POST form data and returns the same response as /fertitude_ussd.
 *
 *
 * Requires:
 *
 * sessionId e.g., lirwf23455
 *
 * phoneNumber e.g., +2348103317200
 *
 * text (location of interest in the pipeline) e.g., "" (empty for first interaction), "1", "1*1", etc. like you would interact with USSD codes
 */
export const ussdPostApiV1TestFertitudeUssdTestFertitudeUssd2Mutation = (
  options?: Partial<
    Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Data>
  >
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Error,
  Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Error,
    Options<UssdPostApiV1TestFertitudeUssdTestFertitudeUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestFertitudeUssdTestFertitudeUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1Test8MedicalUssdTest8MedicalUssd2QueryKey = (
  options: Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Data>
) => createQueryKey("ussdPostApiV1Test8MedicalUssdTest8MedicalUssd2", options);

/**
 * Test 8Medical Ussd
 * Test endpoint for 8Medical_USSD logic.
 */
export const ussdPostApiV1Test8MedicalUssdTest8MedicalUssd2Options = (
  options: Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1Test8MedicalUssdTest8MedicalUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1Test8MedicalUssdTest8MedicalUssd2QueryKey(options),
  });
};

/**
 * Test 8Medical Ussd
 * Test endpoint for 8Medical_USSD logic.
 */
export const ussdPostApiV1Test8MedicalUssdTest8MedicalUssd2Mutation = (
  options?: Partial<Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Data>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Error,
  Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Error,
    Options<UssdPostApiV1Test8MedicalUssdTest8MedicalUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1Test8MedicalUssdTest8MedicalUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestAlajoUssdTestAlajoUssd2QueryKey = (
  options: Options<UssdPostApiV1TestAlajoUssdTestAlajoUssd2Data>
) => createQueryKey("ussdPostApiV1TestAlajoUssdTestAlajoUssd2", options);

/**
 * Test Alajo Ussd
 * Test endpoint for Alajo_USSD logic.
 */
export const ussdPostApiV1TestAlajoUssdTestAlajoUssd2Options = (
  options: Options<UssdPostApiV1TestAlajoUssdTestAlajoUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestAlajoUssdTestAlajoUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestAlajoUssdTestAlajoUssd2QueryKey(options),
  });
};

/**
 * Test Alajo Ussd
 * Test endpoint for Alajo_USSD logic.
 */
export const ussdPostApiV1TestAlajoUssdTestAlajoUssd2Mutation = (
  options?: Partial<Options<UssdPostApiV1TestAlajoUssdTestAlajoUssd2Data>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestAlajoUssdTestAlajoUssd2Error,
  Options<UssdPostApiV1TestAlajoUssdTestAlajoUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestAlajoUssdTestAlajoUssd2Error,
    Options<UssdPostApiV1TestAlajoUssdTestAlajoUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestAlajoUssdTestAlajoUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestClafiyaUssdTestClafiyaUssd2QueryKey = (
  options: Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Data>
) => createQueryKey("ussdPostApiV1TestClafiyaUssdTestClafiyaUssd2", options);

/**
 * Test Clafiya Ussd
 * Test endpoint for Clafiya_USSD logic.
 */
export const ussdPostApiV1TestClafiyaUssdTestClafiyaUssd2Options = (
  options: Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestClafiyaUssdTestClafiyaUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestClafiyaUssdTestClafiyaUssd2QueryKey(options),
  });
};

/**
 * Test Clafiya Ussd
 * Test endpoint for Clafiya_USSD logic.
 */
export const ussdPostApiV1TestClafiyaUssdTestClafiyaUssd2Mutation = (
  options?: Partial<Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Data>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Error,
  Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Error,
    Options<UssdPostApiV1TestClafiyaUssdTestClafiyaUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestClafiyaUssdTestClafiyaUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestEvetUssdTestEvetUssd2QueryKey = (
  options: Options<UssdPostApiV1TestEvetUssdTestEvetUssd2Data>
) => createQueryKey("ussdPostApiV1TestEvetUssdTestEvetUssd2", options);

/**
 * Test Evet Ussd
 * Test endpoint for Evet_USSD logic.
 */
export const ussdPostApiV1TestEvetUssdTestEvetUssd2Options = (
  options: Options<UssdPostApiV1TestEvetUssdTestEvetUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestEvetUssdTestEvetUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestEvetUssdTestEvetUssd2QueryKey(options),
  });
};

/**
 * Test Evet Ussd
 * Test endpoint for Evet_USSD logic.
 */
export const ussdPostApiV1TestEvetUssdTestEvetUssd2Mutation = (
  options?: Partial<Options<UssdPostApiV1TestEvetUssdTestEvetUssd2Data>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestEvetUssdTestEvetUssd2Error,
  Options<UssdPostApiV1TestEvetUssdTestEvetUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestEvetUssdTestEvetUssd2Error,
    Options<UssdPostApiV1TestEvetUssdTestEvetUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestEvetUssdTestEvetUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestFologUssdTestFologUssd2QueryKey = (
  options: Options<UssdPostApiV1TestFologUssdTestFologUssd2Data>
) => createQueryKey("ussdPostApiV1TestFologUssdTestFologUssd2", options);

/**
 * Test Folog Ussd
 * Test endpoint for Folog_USSD logic.
 */
export const ussdPostApiV1TestFologUssdTestFologUssd2Options = (
  options: Options<UssdPostApiV1TestFologUssdTestFologUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestFologUssdTestFologUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestFologUssdTestFologUssd2QueryKey(options),
  });
};

/**
 * Test Folog Ussd
 * Test endpoint for Folog_USSD logic.
 */
export const ussdPostApiV1TestFologUssdTestFologUssd2Mutation = (
  options?: Partial<Options<UssdPostApiV1TestFologUssdTestFologUssd2Data>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestFologUssdTestFologUssd2Error,
  Options<UssdPostApiV1TestFologUssdTestFologUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestFologUssdTestFologUssd2Error,
    Options<UssdPostApiV1TestFologUssdTestFologUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestFologUssdTestFologUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestMylturaUssdTestMylturaUssd2QueryKey = (
  options: Options<UssdPostApiV1TestMylturaUssdTestMylturaUssd2Data>
) => createQueryKey("ussdPostApiV1TestMylturaUssdTestMylturaUssd2", options);

/**
 * Test Myltura Ussd
 * Test endpoint for Myltura_USSD logic.
 */
export const ussdPostApiV1TestMylturaUssdTestMylturaUssd2Options = (
  options: Options<UssdPostApiV1TestMylturaUssdTestMylturaUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestMylturaUssdTestMylturaUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestMylturaUssdTestMylturaUssd2QueryKey(options),
  });
};

/**
 * Test Myltura Ussd
 * Test endpoint for Myltura_USSD logic.
 */
export const ussdPostApiV1TestMylturaUssdTestMylturaUssd2Mutation = (
  options?: Partial<Options<UssdPostApiV1TestMylturaUssdTestMylturaUssd2Data>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestMylturaUssdTestMylturaUssd2Error,
  Options<UssdPostApiV1TestMylturaUssdTestMylturaUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestMylturaUssdTestMylturaUssd2Error,
    Options<UssdPostApiV1TestMylturaUssdTestMylturaUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestMylturaUssdTestMylturaUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestUhcTechUssdTestUhcTechUssd2QueryKey = (
  options: Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Data>
) => createQueryKey("ussdPostApiV1TestUhcTechUssdTestUhcTechUssd2", options);

/**
 * Test Uhc Tech Ussd
 * Test endpoint for UHC_Tech_USSD logic.
 */
export const ussdPostApiV1TestUhcTechUssdTestUhcTechUssd2Options = (
  options: Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestUhcTechUssdTestUhcTechUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestUhcTechUssdTestUhcTechUssd2QueryKey(options),
  });
};

/**
 * Test Uhc Tech Ussd
 * Test endpoint for UHC_Tech_USSD logic.
 */
export const ussdPostApiV1TestUhcTechUssdTestUhcTechUssd2Mutation = (
  options?: Partial<Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Data>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Error,
  Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Error,
    Options<UssdPostApiV1TestUhcTechUssdTestUhcTechUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestUhcTechUssdTestUhcTechUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const ussdPostApiV1TestXboxUssdTestXboxUssd2QueryKey = (
  options: Options<UssdPostApiV1TestXboxUssdTestXboxUssd2Data>
) => createQueryKey("ussdPostApiV1TestXboxUssdTestXboxUssd2", options);

/**
 * Test Xbox Ussd
 * Test endpoint for XBOX_USSD logic.
 */
export const ussdPostApiV1TestXboxUssdTestXboxUssd2Options = (
  options: Options<UssdPostApiV1TestXboxUssdTestXboxUssd2Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await ussdPostApiV1TestXboxUssdTestXboxUssd2({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: ussdPostApiV1TestXboxUssdTestXboxUssd2QueryKey(options),
  });
};

/**
 * Test Xbox Ussd
 * Test endpoint for XBOX_USSD logic.
 */
export const ussdPostApiV1TestXboxUssdTestXboxUssd2Mutation = (
  options?: Partial<Options<UssdPostApiV1TestXboxUssdTestXboxUssd2Data>>
): UseMutationOptions<
  unknown,
  UssdPostApiV1TestXboxUssdTestXboxUssd2Error,
  Options<UssdPostApiV1TestXboxUssdTestXboxUssd2Data>
> => {
  const mutationOptions: UseMutationOptions<
    unknown,
    UssdPostApiV1TestXboxUssdTestXboxUssd2Error,
    Options<UssdPostApiV1TestXboxUssdTestXboxUssd2Data>
  > = {
    mutationFn: async (localOptions) => {
      const { data } = await ussdPostApiV1TestXboxUssdTestXboxUssd2({
        ...options,
        ...localOptions,
        throwOnError: true,
      });
      return data;
    },
  };
  return mutationOptions;
};

export const apiGetMetricsMetrics3QueryKey = (
  options?: Options<ApiGetMetricsMetrics3Data>
) => createQueryKey("apiGetMetricsMetrics3", options);

/**
 * Metrics
 * Endpoint that serves Prometheus metrics.
 */
export const apiGetMetricsMetrics3Options = (
  options?: Options<ApiGetMetricsMetrics3Data>
) => {
  return queryOptions({
    queryFn: async ({ queryKey, signal }) => {
      const { data } = await apiGetMetricsMetrics3({
        ...options,
        ...queryKey[0],
        signal,
        throwOnError: true,
      });
      return data;
    },
    queryKey: apiGetMetricsMetrics3QueryKey(options),
  });
};
